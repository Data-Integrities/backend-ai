<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="expires" content="0">
    <title>Infrastructure AI Hub</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&display=swap" rel="stylesheet">
    
    <!-- Alpine.js - Added but not yet used -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Shoelace - Added but not yet used -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.11.2/cdn/themes/dark.css" />
    <script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.11.2/cdn/shoelace-autoloader.js"></script>
    
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3a3a3a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --accent-primary: #3498db;
            --accent-hover: #2980b9;
            --border-color: #444;
            --success: #27ae60;
            --error: #e74c3c;
            --warning: #f39c12;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            height: calc(100vh - 22px); /* Account for status bar */
            margin-bottom: 22px;
        }
        
        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .sidebar-header h2 {
            font-size: 18px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .agents-section {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .agents-section h3 {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .hamburger-menu {
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
            position: relative;
        }
        
        .hamburger-menu:hover {
            background: var(--bg-tertiary);
        }
        
        .hamburger-icon {
            width: 18px;
            height: 14px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .hamburger-line {
            width: 100%;
            height: 2px;
            background: var(--text-secondary);
            border-radius: 1px;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 4px;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }
        
        .dropdown-menu.open {
            display: block;
        }
        
        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            white-space: nowrap;
            font-size: 13px;
        }
        
        .dropdown-item:hover {
            background: var(--bg-secondary);
        }
        
        .dropdown-divider {
            height: 1px;
            background: var(--border-color);
            margin: 4px 0;
        }
        
        .agent-item {
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .agent-item:hover {
            background: #404040;
            border-color: var(--accent-primary);
        }
        
        .agent-item.selected {
            background: rgba(52, 152, 219, 0.2);
            border-color: var(--accent-primary);
        }
        
        .agent-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        /* Removed old status dot styles - now using letter indicators */
        
        .agent-status-container {
            display: inline-flex;
            gap: 4px;
            margin-right: 8px;
            align-items: center;
        }
        
        .status-indicator {
            display: inline-block;
            width: 24px;
            height: 24px;
            font-family: 'Permanent Marker', cursive;
            font-weight: 400;
            font-size: 16px;
            line-height: 24px;
            text-align: center;
            margin: 0 2px;
            letter-spacing: 0;
            text-shadow: 
                2px 2px 0px rgba(0,0,0,0.2),
                1px 1px 2px rgba(0,0,0,0.3);
            transition: transform 0.2s ease;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
        }
        
        .status-indicator:hover {
            transform: scale(1.15) rotate(-5deg);
        }
        
        .status-indicator.status-online {
            color: #4fc14e;
            background: none;
        }
        
        .status-indicator.status-offline {
            color: #ff5252;
            background: none;
        }
        
        .status-indicator.status-unknown {
            color: #ff5252;  /* Show unknown as red (not running) */
            background: none;
        }
        
        .status-warning { 
            background: #ff8800;
            box-shadow: 0 0 4px #ff8800;
        }
        
        .agent-name {
            font-weight: 500;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .agent-version {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .agent-ip {
            font-size: 12px;
            color: var(--text-secondary);
            margin-left: auto;
        }
        
        .agent-details {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .agent-versions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .version-left {
            text-align: left;
        }
        
        .version-right {
            text-align: right;
        }
        
        /* Main Content Area */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
        }
        
        /* Tab Bar */
        .tab-bar {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            min-height: 48px;
            align-items: flex-end;
            padding: 0 10px;
            gap: 4px;
        }
        
        .tab {
            display: flex;
            align-items: center;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            transition: all 0.2s;
            max-width: 200px;
            position: relative;
            bottom: -1px;
        }
        
        .tab:hover {
            background: #404040;
        }
        
        .tab.active {
            background: var(--bg-primary);
            border-color: var(--border-color);
            color: var(--text-primary);
        }
        
        .tab-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 14px;
            margin-right: 8px;
        }
        
        .tab-close {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .tab-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab.new-chat {
            background: transparent;
            border: 1px dashed var(--border-color);
            color: var(--text-secondary);
        }
        
        .tab.new-chat:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        /* Chat Area */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 70px); /* 48px header + 22px status bar */
            transition: height 0.3s ease;
        }
        
        /* When console is visible, reduce chat container height */
        body.console-visible .chat-container {
            height: calc(100vh - 70px - 25vh); /* Subtract console height */
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            scroll-behavior: smooth;
        }
        
        /* New Chat Form */
        .new-chat-form {
            width: 90%;
            max-width: none;
            margin: 100px auto;
            text-align: center;
        }
        
        .new-chat-form h2 {
            font-size: 32px;
            margin-bottom: 40px;
            font-weight: 300;
        }
        
        .form-group {
            margin-bottom: 24px;
            text-align: left;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.2s;
        }
        
        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
        }
        
        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .start-task-btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .start-task-btn:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }
        
        .start-task-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Chat Messages */
        .message {
            margin-bottom: 16px;
            display: flex;
            align-items: flex-start;
            animation: fadeIn 0.3s ease-in;
            position: relative;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message.user {
            flex-direction: row-reverse;
        }
        
        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            margin: 0 12px;
            flex-shrink: 0;
        }
        
        .message.user .message-avatar {
            background: var(--accent-primary);
        }
        
        .message.ai .message-avatar {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }
        
        .message-content {
            max-width: 70%;
            background: var(--bg-secondary);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
        }
        
        .message.user .message-content {
            background: var(--accent-primary);
            border-color: transparent;
        }
        
        .message-time {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .message.user .message-time {
            text-align: right;
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* Markdown styling within messages */
        .message-content h1,
        .message-content h2,
        .message-content h3,
        .message-content h4,
        .message-content h5,
        .message-content h6 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            line-height: 1.25;
        }
        
        .message-content h1 { font-size: 1.5em; }
        .message-content h2 { font-size: 1.3em; }
        .message-content h3 { font-size: 1.1em; }
        .message-content h4 { font-size: 1em; }
        .message-content h5 { font-size: 0.9em; }
        .message-content h6 { font-size: 0.85em; }
        
        .message-content p {
            margin: 8px 0;
            line-height: 1.5;
        }
        
        .message-content code {
            background: rgba(0, 0, 0, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
        }
        
        .message-content pre {
            background: rgba(0, 0, 0, 0.1);
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 8px 0;
        }
        
        .message-content pre code {
            background: none;
            padding: 0;
        }
        
        .message-content ul,
        .message-content ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        
        .message-content li {
            margin: 4px 0;
            line-height: 1.5;
        }
        
        .message-content blockquote {
            border-left: 4px solid var(--accent-primary);
            margin: 8px 0;
            padding-left: 16px;
            color: var(--text-secondary);
            font-style: italic;
        }
        
        .message-content a {
            color: var(--accent-primary);
            text-decoration: none;
            border-bottom: 1px solid transparent;
            transition: border-color 0.2s;
        }
        
        .message-content a:hover {
            border-bottom-color: var(--accent-primary);
        }
        
        .message-content table {
            border-collapse: collapse;
            margin: 8px 0;
            width: 100%;
        }
        
        .message-content th,
        .message-content td {
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            text-align: left;
        }
        
        .message-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }
        
        .message-content hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 16px 0;
        }
        
        /* Copy button styles */
        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            opacity: 0;
            transition: all 0.2s;
        }
        
        .message:hover .copy-btn {
            opacity: 1;
        }
        
        .copy-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        /* Error details styles */
        .error-details-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            margin-left: 8px;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .error-details-btn:hover {
            background: rgba(231, 76, 60, 0.1);
        }
        
        .error-details {
            margin-top: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(231, 76, 60, 0.3);
            border-radius: 6px;
            font-family: monospace;
            font-size: 12px;
            color: #e74c3c;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        /* Markdown tabs */
        .markdown-tabs {
            margin-top: 8px;
        }
        
        .tab-buttons {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .tab-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 6px 12px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .tab-btn:hover {
            color: var(--text-primary);
        }
        
        .tab-btn.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
        }
        
        .tab-content {
            padding: 8px 0;
        }
        
        .tab-content.raw pre {
            background: rgba(0, 0, 0, 0.2);
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 13px;
            margin: 0;
        }
        
        /* Markdown rendered styles */
        .tab-content.rendered h1,
        .tab-content.rendered h2,
        .tab-content.rendered h3,
        .tab-content.rendered h4,
        .tab-content.rendered h5,
        .tab-content.rendered h6 {
            margin: 16px 0 8px 0;
            font-weight: 600;
        }
        
        .tab-content.rendered h1 { font-size: 24px; }
        .tab-content.rendered h2 { font-size: 20px; }
        .tab-content.rendered h3 { font-size: 18px; }
        .tab-content.rendered h4 { font-size: 16px; }
        .tab-content.rendered h5 { font-size: 14px; }
        .tab-content.rendered h6 { font-size: 13px; }
        
        .tab-content.rendered ul,
        .tab-content.rendered ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        
        .tab-content.rendered li {
            margin: 4px 0;
        }
        
        .tab-content.rendered blockquote {
            margin: 8px 0;
            padding-left: 16px;
            border-left: 4px solid var(--border-color);
            color: var(--text-secondary);
        }
        
        .tab-content.rendered code {
            background: rgba(0, 0, 0, 0.3);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }
        
        .tab-content.rendered pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 8px 0;
        }
        
        .tab-content.rendered pre code {
            background: none;
            padding: 0;
        }
        
        .tab-content.rendered a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        .tab-content.rendered a:hover {
            text-decoration: underline;
        }
        
        /* Agent routing indicator */
        .agent-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-tertiary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-top: 8px;
            color: var(--text-secondary);
        }
        
        /* Input Area */
        .chat-input-container {
            padding: 20px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .input-wrapper {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        .chat-input {
            flex: 1;
            min-height: 44px;
            max-height: 120px;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 16px;
            resize: none;
            outline: none;
            transition: all 0.2s;
        }
        
        .chat-input:focus {
            border-color: var(--accent-primary);
            background: #404040;
        }
        
        .send-button {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .send-button:hover:not(:disabled) {
            background: var(--accent-hover);
        }
        
        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Console Window */
        .console-window {
            position: fixed;
            bottom: 22px; /* Above status bar */
            left: 0;
            right: 0;
            height: 25vh; /* 1/4 of viewport height */
            background: #1e1e1e;
            border-top: 1px solid var(--border-color);
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 999;
            display: flex;
            flex-direction: column;
        }
        
        .console-window.visible {
            transform: translateY(0);
        }
        
        .console-header {
            background: #2d2d30;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-primary);
        }
        
        .console-tabs {
            display: flex;
            gap: 10px;
            height: 100%;
            align-items: center;
        }
        
        .console-tab {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 12px;
            font-size: 12px;
            border-radius: 4px 4px 0 0;
            transition: all 0.2s;
        }
        
        .console-tab:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .console-tab.active {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .console-tab-content {
            display: none;
            height: 100%;
            overflow-y: auto;
        }
        
        .console-tab-content.active {
            display: block;
        }
        
        .console-clear-button {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: background 0.2s, color 0.2s;
        }
        
        .console-clear-button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }
        
        .console-clear-button:active {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .console-content {
            flex: 1;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 8px 12px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .console-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 11px;
        }
        
        .console-table th {
            background: #2d2d30;
            color: #cccccc;
            padding: 6px 8px;
            text-align: left;
            border-bottom: 1px solid #3e3e42;
            font-weight: 500;
        }
        
        .console-table td {
            padding: 4px 8px;
            border-bottom: 1px solid #2d2d30;
            vertical-align: top;
        }
        
        .console-table tr:hover {
            background: #2a2d2e;
        }
        
        .console-row-child {
            padding-left: 20px;
            opacity: 0.8;
        }
        
        .console-row-child::before {
            content: "↳ ";
            margin-right: 4px;
            opacity: 0.6;
        }
        
        .status-polling {
            color: #ffcc02;
        }
        
        .status-completed {
            color: #89d185;
        }
        
        .status-failed {
            color: #f85149;
        }
        
        .status-timeout {
            color: #ff9500; /* orange */
        }
        
        .status-debug {
            color: #b392f0; /* purple */
        }
        
        .status-info {
            color: #58a6ff; /* blue */
        }
        
        .status-timeout-success {
            color: #ffcc02; /* yellow */
        }
        
        .status-manual-termination {
            color: #ff9500; /* orange */
        }
        
        .status-partial-success {
            color: #ffcc02; /* yellow */
        }
        
        /* Status Bar - VSCode Style */
        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 22px;
            background: #007ACC;
            display: flex;
            align-items: center;
            z-index: 1000;
            font-size: 12px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        .status-segment {
            display: flex;
            align-items: center;
            padding: 0 10px;
            height: 100%;
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            transition: background-color 0.1s;
        }
        
        .status-segment:hover {
            background-color: rgba(255, 255, 255, 0.12);
        }
        
        .status-segment.clickable:active {
            background-color: rgba(255, 255, 255, 0.18);
        }
        
        .status-segment:not(:last-child)::after {
            content: '';
            position: absolute;
            right: 0;
            top: 2px;
            bottom: 2px;
            width: 1px;
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .status-segment {
            position: relative;
        }
        
        .status-segment.right {
            margin-left: auto;
        }
        
        .console-toggle {
            cursor: pointer;
            padding: 0 8px;
            height: 22px;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: background 0.2s;
        }
        
        .console-toggle:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .console-arrow {
            font-size: 10px;
            transition: transform 0.3s ease;
        }
        
        .console-arrow.up {
            transform: rotate(180deg);
        }
        
        .status-icon {
            margin-right: 4px;
            font-size: 14px;
        }
        
        .status-value {
            color: white;
            font-weight: normal;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
        }
        
        .modal.open {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 24px;
            padding: 4px;
        }
        
        .btn {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--primary-hover);
        }
        
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .history-item {
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
        
        .history-item:hover {
            border-color: var(--accent-primary);
        }
        
        .history-title {
            font-weight: 500;
            margin-bottom: 4px;
        }
        
        .history-preview {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .history-meta {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        /* Loading states */
        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px;
        }
        
        .typing-dot {
            width: 8px;
            height: 8px;
            background: var(--text-secondary);
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }
        
        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-10px); opacity: 1; }
        }
        
        /* Quick actions */
        .quick-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }
        
        .quick-action {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-action:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            background-color: var(--bg-secondary);
            margin: 5% auto;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        .modal-header {
            background: var(--bg-primary);
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            color: var(--text-primary);
        }
        
        /* Compact log viewer styles */
        .log-viewer-modal .modal-content {
            position: fixed;
            top: 10vh;
            left: 50%;
            transform: translateX(-50%);
            margin: 0;
            height: 80vh;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent modal itself from scrolling */
        }
        
        .log-viewer-modal .modal-header {
            padding: 8px 15px;
            flex-shrink: 0;
        }
        
        .log-viewer-modal .modal-header h2 {
            font-size: 14px;
        }
        
        .log-viewer-modal .modal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden; /* Prevent body from scrolling */
        }
        
        /* Fixed command info section */
        .log-viewer-modal .command-info-section {
            flex-shrink: 0;
            padding-bottom: 10px;
        }
        
        /* Container for timeline and logs sections */
        .log-viewer-modal .sections-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            gap: 10px;
        }
        
        /* Timeline section - 50% height */
        .log-viewer-modal .timeline-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .log-viewer-modal .timeline-section h3 {
            flex-shrink: 0;
            margin-top: 0;
            margin-bottom: 8px;
        }
        
        .log-viewer-modal .timeline-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
            min-height: 0;
        }
        
        /* Logs section - 50% height */
        .log-viewer-modal .logs-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            overflow: hidden;
        }
        
        .log-viewer-modal .logs-section h3 {
            flex-shrink: 0;
            margin-top: 0;
            margin-bottom: 8px;
        }
        
        .log-viewer-modal .logs-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding-right: 5px;
            min-height: 0;
        }
        
        /* Subtle scrollbar styles with hover effect */
        .timeline-content::-webkit-scrollbar,
        .logs-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        .timeline-content::-webkit-scrollbar-track,
        .logs-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 4px;
        }
        
        .timeline-content::-webkit-scrollbar-thumb,
        .logs-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.075);
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        .timeline-content:hover::-webkit-scrollbar-thumb,
        .logs-content:hover::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .timeline-content::-webkit-scrollbar-thumb:hover,
        .logs-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .log-viewer-modal .command-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .log-viewer-modal .command-info-row {
            display: flex;
            gap: 15px;
        }
        
        .log-viewer-modal h3 {
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .modal-body {
            padding: 20px;
            color: var(--text-primary);
        }
        
        .modal-body pre {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .modal-body h3 {
            margin-top: 0;
            color: var(--text-primary);
        }
        
        .modal-body h4 {
            margin-top: 16px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }
        
        .close-button {
            color: var(--text-muted);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        
        .close-button:hover {
            color: var(--text-primary);
        }
        
        .log-link {
            text-decoration: none;
            margin-left: 8px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        
        .log-link:hover {
            opacity: 1;
        }
        
        .log-section {
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }
        
        .log-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .log-section h4 {
            color: var(--accent-primary);
            font-size: 14px;
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        .modal-body code {
            background: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            color: var(--accent-primary);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>🚀 AI Control Hub</h2>
            </div>
            
            <div class="agents-section">
                <h3>
                    Connected Agents
                    <div class="hamburger-menu" x-data="{ open: false }" @click.away="open = false">
                        <div class="hamburger-icon" @click="open = !open">
                            <div class="hamburger-line"></div>
                            <div class="hamburger-line"></div>
                            <div class="hamburger-line"></div>
                        </div>
                        <div class="dropdown-menu" :class="{ 'open': open }" x-show="open" x-transition>
                            <div class="dropdown-item" @click="window.performControlAction('startAllAgents'); open = false">Start All Agents</div>
                            <div class="dropdown-item" @click="window.performControlAction('stopAllAgents'); open = false">Stop All Agents</div>
                            <div class="dropdown-divider"></div>
                            <div class="dropdown-item" @click="window.performControlAction('startAllManagers'); open = false">Start All Managers</div>
                            <div class="dropdown-item" @click="window.performControlAction('stopAllManagers'); open = false">Stop All Managers</div>
                        </div>
                    </div>
                </h3>
                <div id="agents-list">
                    <!-- Agents will be populated here -->
                </div>
            </div>
            
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Tab Bar -->
            <div class="tab-bar" id="tab-bar">
                <div class="tab new-chat active" data-tab-id="new" onclick="window.performControlAction('switchTab', {tabId: 'new'})">
                    <span class="tab-title">+ New Chat</span>
                </div>
            </div>
            
            <!-- Chat Containers -->
            <div id="chat-containers">
                <!-- New Chat Container -->
                <div class="chat-container" data-tab-id="new">
                    <div class="new-chat-form">
                        <h2>Start a New Task</h2>
                        <form onsubmit="event.preventDefault(); const title = document.getElementById('task-title').value.trim(); const command = document.getElementById('task-command').value.trim(); window.performChatAction('startTask', {tabTitle: title, initialPrompt: command});">
                            <div class="form-group">
                                <label for="task-command">What would you like to do?</label>
                                <textarea 
                                    id="task-command" 
                                    placeholder="Describe your task in natural language..."
                                    required
                                    onkeydown="handleFormKeydown(event)"
                                    oninput="autoPopulateTitle(event)"
                                    tabindex="1"
                                    autofocus
                                ></textarea>
                            </div>
                            <div class="form-group">
                                <label for="task-title">Task Title</label>
                                <input 
                                    type="text" 
                                    id="task-title" 
                                    placeholder="e.g., Setup Linux Container, Configure SSL"
                                    required
                                    tabindex="2"
                                    oninput="this.dataset.userModified = 'true'"
                                />
                            </div>
                            <button type="submit" class="start-task-btn" tabindex="3">
                                Start Task
                            </button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Console Window -->
    <div class="console-window" id="console-window">
        <div class="console-header">
            <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                <div style="display: flex; align-items: center;">
                    <span>Console</span>
                    <!-- Console Tabs -->
                    <div class="console-tabs" style="margin-left: 20px;">
                        <button class="console-tab active" id="chat-tab" onclick="window.performControlAction('switchConsoleTab', {tab: 'chat'})">Chat</button>
                        <button class="console-tab" id="control-tab" onclick="window.performControlAction('switchConsoleTab', {tab: 'control'})">Control</button>
                    </div>
                </div>
                <button class="console-clear-button" onclick="window.performControlAction('clearConsole')" title="Clear Current Tab" style="margin-left: 15px;">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                        <!-- 4 horizontal lines -->
                        <path d="M2 3h12v1H2zM2 5h12v1H2zM2 7h12v1H2zM2 9h12v1H2z"/>
                        <!-- X in bottom right -->
                        <path d="M11.854 11.146a.5.5 0 010 .708l-1 1a.5.5 0 01-.708 0L9 11.707l-1.146 1.147a.5.5 0 01-.708 0l-1-1a.5.5 0 010-.708L7.293 10 6.146 8.854a.5.5 0 010-.708l1-1a.5.5 0 01.708 0L9 8.293l1.146-1.147a.5.5 0 01.708 0l1 1a.5.5 0 010 .708L10.707 10l1.147 1.146z" transform="translate(2, 2) scale(0.8)"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="console-content" id="console-content">
            <!-- Control Tab Content -->
            <div id="control-console" class="console-tab-content">
                <table class="console-table" id="console-table">
                    <thead>
                        <tr>
                            <th>Start</th>
                            <th>Agent</th>
                            <th>Command</th>
                            <th>Completion DT</th>
                            <th>Status</th>
                            <th>View Log</th>
                        </tr>
                    </thead>
                    <tbody id="console-table-body">
                        <!-- Command rows will be added here -->
                    </tbody>
                </table>
            </div>
            <!-- Chat Tab Content -->
            <div id="chat-console" class="console-tab-content active">
                <table class="console-table" id="chat-console-table">
                    <thead>
                        <tr>
                            <th>Start</th>
                            <th>Tab</th>
                            <th>Action</th>
                            <th>Details</th>
                            <th>Status</th>
                            <th>View Log</th>
                        </tr>
                    </thead>
                    <tbody id="chat-console-table-body">
                        <!-- Chat action rows will be added here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Status Bar -->
    <div class="status-bar">
        <div class="status-segment">
            <span class="status-icon">🤖</span>
            <span id="agent-count">0/0</span>
        </div>
        <div class="status-segment">
            <span class="status-icon">📡</span>
            <span id="connection-status">Connected</span>
        </div>
        <div class="status-segment">
            <span>Hub v<span id="hub-version">2.0.9</span></span>
        </div>
        <div class="console-toggle" onclick="window.performControlAction('toggleConsole')">
            <span>Console</span>
            <span class="console-arrow" id="console-arrow">▲</span>
        </div>
        <div class="status-segment right">
            <span id="last-update">Never</span>
        </div>
    </div>
    
    <!-- History Modal -->
    <div id="history-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Chat History</h2>
                <button class="modal-close" onclick="window.performControlAction('closeHistoryModal')">×</button>
            </div>
            <div class="modal-body" id="history-list">
                <!-- History items will be populated here -->
            </div>
        </div>
    </div>
    
    <!-- Summary Modal for Start/Stop All -->
    <div id="summary-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="summary-title">Operation Summary</h2>
                <button class="modal-close" onclick="window.performControlAction('closeSummaryModal')">×</button>
            </div>
            <div class="modal-body" id="summary-content">
                <!-- Summary content will be populated here -->
            </div>
            <div class="modal-footer" style="text-align: center; padding: 15px; border-top: 1px solid var(--border-color);">
                <button class="btn btn-primary" onclick="window.performControlAction('closeSummaryModal')">OK</button>
            </div>
        </div>
    </div>
    
    <script>
        // Single source of truth for version
        const HUB_VERSION = '2.1.64';
        
        // Tab identification system - generates new ID on every refresh
        const TAB_ID = `tab_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // Update page title with version and tab ID
        document.title = `Infrastructure AI Hub [${TAB_ID}] (v${HUB_VERSION})`;
        
        // In-memory storage for chat actions (cleared on refresh like control logs)
        let chatActions = [];
        
        // Track active task correlationIds per tab (for parent-child relationships)
        const activeTaskCorrelations = new Map();
        
        // In-memory storage for hub GUI logs (cleared on refresh)
        let hubGuiLogs = [];
        
        // Hub GUI Logging System
        const hubGuiLog = {
            log: function(worker, correlationId, action, description, error = null) {
                const entry = {
                    worker,
                    correlationId,
                    datetime: new Date().toISOString(),
                    action,
                    description,
                    error
                };
                hubGuiLogs.push(entry);
                
                // Keep last 1000 entries
                if (hubGuiLogs.length > 1000) {
                    hubGuiLogs.shift();
                }
                console.log(`[GUI-LOG] ${action}:`, description, entry);
            },
            
            getLogs: function(filter = {}) {
                let filtered = [...hubGuiLogs];
                
                if (filter.worker) {
                    filtered = filtered.filter(l => l.worker === filter.worker);
                }
                if (filter.correlationId) {
                    filtered = filtered.filter(l => l.correlationId === filter.correlationId);
                }
                if (filter.action) {
                    filtered = filtered.filter(l => l.action === filter.action);
                }
                if (filter.from) {
                    filtered = filtered.filter(l => new Date(l.datetime) >= new Date(filter.from));
                }
                if (filter.to) {
                    filtered = filtered.filter(l => new Date(l.datetime) <= new Date(filter.to));
                }
                if (filter.last) {
                    filtered = filtered.slice(-filter.last);
                }
                
                return filtered;
            },
            
            clear: function() {
                sessionStorage.removeItem('hubGuiLogs');
                console.log('[GUI-LOG] Logs cleared');
            }
        };
        
        // Browser Request Handler - Processes requests from the hub API
        class BrowserRequestHandler {
            constructor() {
                this.handlers = new Map();
                this.registerHandlers();
                this.lastCheck = 0;
                this.checkInterval = 250; // Check every 250ms for responsive RPC
                
                // Start checking for requests
                this.startRequestPolling();
            }
            
            registerHandlers() {
                // Generic action handler - routes ALL actions through performAction
                this.handlers.set('performControlAction', async (params) => {
                    if (!params.action) {
                        throw new Error('action parameter is required');
                    }
                    // Mark as RPC call for delay handling
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performControlAction(params.action, params.params || {});
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                this.handlers.set('performChatAction', async (params) => {
                    if (!params.action) {
                        throw new Error('action parameter is required');
                    }
                    // Mark as RPC call for delay handling
                    const wasRpcCall = window.actionRouter.isRpcCall;
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction(params.action, params.params || {});
                    } finally {
                        // Only reset if we set it (don't interfere with nested calls)
                        if (!wasRpcCall) {
                            window.actionRouter.isRpcCall = false;
                        }
                    }
                });
                
                // Data request handlers
                this.handlers.set('getLogs', async (params) => {
                    return hubGuiLog.getLogs(params);
                });
                
                this.handlers.set('getInterleavedLogs', async (params) => {
                    if (!params.correlationId) {
                        throw new Error('correlationId is required');
                    }
                    
                    // Get UI logs for this correlationId
                    const uiLogs = hubGuiLog.getLogs({ correlationId: params.correlationId });
                    
                    // Get backend logs via existing endpoint
                    try {
                        const response = await fetch(`${API_BASE}/executions/${params.correlationId}/logs`);
                        const backendLogs = await response.json();
                        
                        // Merge and sort by timestamp
                        const allLogs = [...uiLogs, ...backendLogs];
                        allLogs.sort((a, b) => new Date(a.datetime || a.timestamp).getTime() - new Date(b.datetime || b.timestamp).getTime());
                        
                        return allLogs;
                    } catch (error) {
                        // If backend logs fail, return just UI logs
                        return uiLogs;
                    }
                });
                
                this.handlers.set('getState', async (params) => {
                    const agents = Array.from(document.querySelectorAll('.agent-card')).map(card => {
                        const agentIndicator = card.querySelector('.agent-indicator');
                        const managerIndicator = card.querySelector('.manager-indicator');
                        return {
                            name: card.dataset.agent,
                            agentOnline: agentIndicator ? agentIndicator.classList.contains('online') : false,
                            managerOnline: managerIndicator ? managerIndicator.classList.contains('online') : false
                        };
                    });
                    
                    const commands = getStoredCommands();
                    const consolePanel = document.getElementById('console-panel');
                    
                    return {
                        tabId: TAB_ID,
                        url: window.location.href,
                        agents: agents,
                        consoleVisible: consolePanel ? consolePanel.classList.contains('open') : false,
                        pendingCommands: commands.filter(c => c.status === 'pending').length,
                        totalCommands: commands.length,
                        activeTab: activeTabId,
                        timestamp: new Date().toISOString()
                    };
                });
                
                this.handlers.set('getConsoleEntries', async (params) => {
                    const commands = getStoredCommands();
                    return params.last ? commands.slice(-params.last) : commands;
                });
                
                this.handlers.set('getChatLogs', async (params) => {
                    // Directly call the action to get the chat logs
                    // Don't use performControlAction as it returns async status
                    const action = window.actionRouter.actions.get('getChatLogs');
                    if (action) {
                        return await action(params);
                    }
                    return { success: false, error: 'getChatLogs action not found' };
                });
                
                this.handlers.set('getTabs', async (params) => {
                    // Forward to performChatAction to get tab information
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction('getTabs', params);
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                this.handlers.set('getActiveTab', async (params) => {
                    // Forward to performChatAction to get active tab information
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction('getActiveTab', params);
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                this.handlers.set('setActiveTab', async (params) => {
                    // Forward to performChatAction to set active tab
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction('setActiveTab', params);
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                // New chat-related RPC handlers
                this.handlers.set('newChat', async (params) => {
                    // Don't reset isRpcCall here - let performChatAction handle it
                    // so that child actions also get the RPC delay
                    return await window.performChatAction('newChat', params);
                });
                
                this.handlers.set('setTaskDescription', async (params) => {
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction('setTaskDescription', params);
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                this.handlers.set('setTitle', async (params) => {
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction('setTitle', params);
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                this.handlers.set('startTask', async (params) => {
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction('startTask', params);
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                this.handlers.set('startAgentChat', async (params) => {
                    window.actionRouter.isRpcCall = true;
                    try {
                        return await window.performChatAction('startAgentChat', params);
                    } finally {
                        window.actionRouter.isRpcCall = false;
                    }
                });
                
                this.handlers.set('getFailedCommands', async (params) => {
                    const commands = getStoredCommands();
                    const failed = commands.filter(c => c.status === 'failed' || c.status === 'timeout');
                    return params.last ? failed.slice(-params.last) : failed;
                });
                
                // Control command handlers
                this.handlers.set('startAgent', async (params) => {
                    if (!params.agent) {
                        throw new Error('agent parameter is required');
                    }
                    
                    const button = document.querySelector(`[data-agent="${params.agent}"] .action-button.start-agent`);
                    if (button && !button.disabled) {
                        window.lastCorrelationId = null; // Reset before click
                        button.click();
                        // Wait a bit for the correlationId to be set
                        await new Promise(resolve => setTimeout(resolve, 100));
                        return { 
                            success: true, 
                            agent: params.agent, 
                            action: 'startAgent',
                            correlationId: window.lastCorrelationId
                        };
                    }
                    return { success: false, error: 'Start button not found or disabled' };
                });
                
                this.handlers.set('stopAgent', async (params) => {
                    if (!params.agent) {
                        throw new Error('agent parameter is required');
                    }
                    
                    const button = document.querySelector(`[data-agent="${params.agent}"] .action-button.stop-agent`);
                    if (button && !button.disabled) {
                        window.lastCorrelationId = null; // Reset before click
                        button.click();
                        // Wait a bit for the correlationId to be set
                        await new Promise(resolve => setTimeout(resolve, 100));
                        return { 
                            success: true, 
                            agent: params.agent, 
                            action: 'stopAgent',
                            correlationId: window.lastCorrelationId
                        };
                    }
                    return { success: false, error: 'Stop button not found or disabled' };
                });
                
                this.handlers.set('startManager', async (params) => {
                    if (!params.agent) {
                        throw new Error('agent parameter is required');
                    }
                    
                    const button = document.querySelector(`[data-agent="${params.agent}"] .action-button.start-manager`);
                    if (button && !button.disabled) {
                        window.lastCorrelationId = null; // Reset before click
                        button.click();
                        // Wait a bit for the correlationId to be set
                        await new Promise(resolve => setTimeout(resolve, 100));
                        return { 
                            success: true, 
                            agent: params.agent, 
                            action: 'startManager',
                            correlationId: window.lastCorrelationId
                        };
                    }
                    return { success: false, error: 'Start manager button not found or disabled' };
                });
                
                this.handlers.set('stopManager', async (params) => {
                    if (!params.agent) {
                        throw new Error('agent parameter is required');
                    }
                    
                    const button = document.querySelector(`[data-agent="${params.agent}"] .action-button.stop-manager`);
                    if (button && !button.disabled) {
                        window.lastCorrelationId = null; // Reset before click
                        button.click();
                        // Wait a bit for the correlationId to be set
                        await new Promise(resolve => setTimeout(resolve, 100));
                        return { 
                            success: true, 
                            agent: params.agent, 
                            action: 'stopManager',
                            correlationId: window.lastCorrelationId
                        };
                    }
                    return { success: false, error: 'Stop manager button not found or disabled' };
                });
                
                this.handlers.set('clearConsole', async (params) => {
                    clearConsoleContent();
                    return { success: true, action: 'clearConsole' };
                });
                
                this.handlers.set('clearLogs', async (params) => {
                    hubGuiLog.clear();
                    return { success: true, action: 'clearLogs' };
                });
                
                this.handlers.set('retryCommand', async (params) => {
                    if (!params.commandId) {
                        throw new Error('commandId is required');
                    }
                    
                    const commands = getStoredCommands();
                    const command = commands.find(c => c.id === params.commandId || c.correlationId === params.commandId);
                    
                    if (command) {
                        // Find the agent card and trigger the same action
                        const actionMap = {
                            'start-agent': '.action-button.start-agent',
                            'stop-agent': '.action-button.stop-agent',
                            'start-manager': '.action-button.start-manager',
                            'stop-manager': '.action-button.stop-manager'
                        };
                        
                        const selector = actionMap[command.command];
                        if (selector && command.agent) {
                            const button = document.querySelector(`[data-agent="${command.agent}"] ${selector}`);
                            if (button && !button.disabled) {
                                button.click();
                                return { success: true, retriedCommand: command.command, agent: command.agent };
                            }
                        }
                    }
                    
                    return { success: false, error: 'Command not found or cannot be retried' };
                });
                
                // Hamburger menu commands
                this.handlers.set('startAllAgents', async (params) => {
                    if (typeof window.startAllAgents === 'function') {
                        window.startAllAgents();
                        return { success: true, action: 'startAllAgents' };
                    }
                    return { success: false, error: 'startAllAgents function not found' };
                });
                
                this.handlers.set('stopAllAgents', async (params) => {
                    if (typeof window.stopAllAgents === 'function') {
                        window.stopAllAgents();
                        return { success: true, action: 'stopAllAgents' };
                    }
                    return { success: false, error: 'stopAllAgents function not found' };
                });
                
                this.handlers.set('startAllManagers', async (params) => {
                    if (typeof window.startAllManagers === 'function') {
                        window.startAllManagers();
                        return { success: true, action: 'startAllManagers' };
                    }
                    return { success: false, error: 'startAllManagers function not found' };
                });
                
                this.handlers.set('stopAllManagers', async (params) => {
                    if (typeof window.stopAllManagers === 'function') {
                        window.stopAllManagers();
                        return { success: true, action: 'stopAllManagers' };
                    }
                    return { success: false, error: 'stopAllManagers function not found' };
                });
                
                // Generic action handler for any menu item
                this.handlers.set('clickMenuItem', async (params) => {
                    if (!params.item) {
                        throw new Error('item parameter is required');
                    }
                    
                    // Map of menu items to their functions
                    const menuMap = {
                        'start-all-agents': window.startAllAgents,
                        'stop-all-agents': window.stopAllAgents,
                        'start-all-managers': window.startAllManagers,
                        'stop-all-managers': window.stopAllManagers
                    };
                    
                    const func = menuMap[params.item];
                    if (func && typeof func === 'function') {
                        func();
                        return { success: true, action: params.item };
                    }
                    
                    return { success: false, error: `Unknown menu item: ${params.item}` };
                });
                
                // Wait for command completion
                this.handlers.set('waitForCommand', async (params) => {
                    if (!params.correlationId) {
                        throw new Error('correlationId is required');
                    }
                    
                    const timeout = params.timeout || 30000; // Default 30s timeout
                    const startTime = Date.now();
                    
                    // Check if command is already complete
                    const commands = getStoredCommands();
                    let command = commands.find(c => c.correlationId === params.correlationId);
                    
                    if (command && ['success', 'failed', 'timeout', 'timeoutSuccess'].includes(command.status)) {
                        return {
                            completed: true,
                            status: command.status,
                            duration: command.endTime ? command.endTime - command.startTime : null,
                            command: command
                        };
                    }
                    
                    // Wait for completion
                    while (Date.now() - startTime < timeout) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const updatedCommands = getStoredCommands();
                        command = updatedCommands.find(c => c.correlationId === params.correlationId);
                        
                        if (command && ['success', 'failed', 'timeout', 'timeoutSuccess'].includes(command.status)) {
                            return {
                                completed: true,
                                status: command.status,
                                duration: command.endTime ? command.endTime - command.startTime : null,
                                command: command
                            };
                        }
                    }
                    
                    return {
                        completed: false,
                        error: 'Timeout waiting for command completion',
                        command: command
                    };
                });
                
                // Get command status
                this.handlers.set('getCommandStatus', async (params) => {
                    if (!params.correlationId) {
                        throw new Error('correlationId is required');
                    }
                    
                    const commands = getStoredCommands();
                    const command = commands.find(c => c.correlationId === params.correlationId);
                    
                    if (!command) {
                        return { found: false, error: 'Command not found' };
                    }
                    
                    return {
                        found: true,
                        status: command.status,
                        completed: ['success', 'failed', 'timeout', 'timeoutSuccess'].includes(command.status),
                        command: command
                    };
                });
                
                // Refresh the browser
                this.handlers.set('refreshBrowser', async (params) => {
                    const delay = params.delay || 1000; // Default 1 second delay
                    
                    // Log that we're about to refresh
                    hubGuiLog.log(null, null, 'browser-refresh', `Browser refresh requested, will refresh in ${delay}ms`);
                    
                    // Store the fact that we're refreshing so it can be detected
                    sessionStorage.setItem('refreshRequested', JSON.stringify({
                        timestamp: new Date().toISOString(),
                        tabId: TAB_ID
                    }));
                    
                    // Schedule the refresh
                    setTimeout(() => {
                        window.location.reload();
                    }, delay);
                    
                    return { 
                        success: true, 
                        message: `Browser will refresh in ${delay}ms`,
                        tabId: TAB_ID
                    };
                });
            }
            
            async checkForRequests() {
                // Don't check too frequently
                const now = Date.now();
                if (now - this.lastCheck < 1000) return;
                this.lastCheck = now;
                
                try {
                    // Check for browser requests
                    const response = await fetch(`${API_BASE}/browser-requests/pending/${TAB_ID}`);
                    const { requests } = await response.json();
                    
                    for (const request of requests) {
                        console.log(`[BrowserRequest] Processing request ${request.id}: ${request.action}`);
                        await this.processRequest(request);
                    }
                    
                    // Check for queued commands
                    await this.checkForQueuedCommands();
                } catch (error) {
                    console.error('[BrowserRequest] Failed to check for requests:', error);
                }
            }
            
            async checkForQueuedCommands() {
                try {
                    const response = await fetch(`${API_BASE}/commands/pending`);
                    const { commands } = await response.json();
                    
                    for (const command of commands) {
                        console.log(`[CommandQueue] Processing queued command ${command.id}: ${command.operation} on ${command.agent}`);
                        await this.executeQueuedCommand(command);
                    }
                } catch (error) {
                    console.error('[CommandQueue] Failed to check for commands:', error);
                }
            }
            
            async executeQueuedCommand(command) {
                try {
                    // Mark as processing
                    await fetch(`${API_BASE}/commands/${command.id}/processing`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    });
                    
                    // Find the agent
                    const agents = window.agentsData || [];
                    const agent = agents.find(a => a.name === command.agent);
                    
                    if (!agent) {
                        throw new Error(`Agent ${command.agent} not found`);
                    }
                    
                    // Execute the operation using the action router
                    // This will include addConsoleCommand() so it appears in the console
                    if (window.performAction) {
                        // Store the command ID for completion tracking
                        window.currentQueuedCommandId = command.id;
                        
                        // Use the action router
                        const result = await window.performControlAction(command.operation, { agent: command.agent });
                        
                        if (!result.success) {
                            throw new Error(result.error);
                        }
                        
                        // Mark as completed
                        await fetch(`${API_BASE}/commands/${command.id}/complete`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                result: 'Command initiated',
                                correlationId: window.lastCorrelationId 
                            })
                        });
                    } else {
                        throw new Error('Context menu handler not available');
                    }
                } catch (error) {
                    console.error(`[CommandQueue] Failed to execute command ${command.id}:`, error);
                    
                    // Mark as failed
                    try {
                        await fetch(`${API_BASE}/commands/${command.id}/fail`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ error: error.message })
                        });
                    } catch (failError) {
                        console.error('[CommandQueue] Failed to mark command as failed:', failError);
                    }
                }
            }
            
            async processRequest(request) {
                const handler = this.handlers.get(request.action);
                
                if (!handler) {
                    await this.sendResponse(request.id, null, `Unknown action: ${request.action}`);
                    return;
                }
                
                try {
                    const result = await handler(request.params);
                    await this.sendResponse(request.id, result);
                } catch (error) {
                    await this.sendResponse(request.id, null, error.message);
                }
            }
            
            async sendResponse(requestId, response, error) {
                try {
                    await fetch(`${API_BASE}/browser-requests/${requestId}/response`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ response, error })
                    });
                } catch (err) {
                    console.error(`[BrowserRequest] Failed to send response for ${requestId}:`, err);
                }
            }
            
            startRequestPolling() {
                // Check during EventSource messages
                if (typeof listenForExecutionUpdates !== 'undefined') {
                    const originalHandler = window.executionEventSource?.onmessage;
                    if (originalHandler) {
                        window.executionEventSource.onmessage = (event) => {
                            originalHandler(event);
                            this.checkForRequests();
                        };
                    }
                }
                
                // Also check periodically
                setInterval(() => {
                    this.checkForRequests();
                }, this.checkInterval);
                
                // Check during agent polling
                const originalLoadAgents = window.loadAgents;
                if (originalLoadAgents) {
                    window.loadAgents = async () => {
                        await originalLoadAgents();
                        this.checkForRequests();
                    };
                }
            }
        }
        
        // Initialize browser request handler
        const browserRequestHandler = new BrowserRequestHandler();
        
        // Universal Action Router - ALL UI actions go through here
        class ActionRouter {
            constructor() {
                this.actions = new Map();
                this.rpcDelay = 500; // Default 500ms delay between RPC actions
                this.isRpcCall = false; // Track if current action is from RPC
                this.registerActions();
                window.performControlAction = this.performControlAction.bind(this);
                window.performChatAction = this.performChatAction.bind(this);
            }
            
            registerActions() {
                // Agent context menu actions
                this.actions.set('startAgent', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    await window.executeAgentOperation(agent, 'start');
                });
                
                this.actions.set('stopAgent', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    await window.executeAgentOperation(agent, 'stop');
                });
                
                this.actions.set('restartAgent', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    await window.executeAgentOperation(agent, 'restart');
                });
                
                this.actions.set('startManager', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    await window.executeAgentOperation(agent, 'start-manager');
                });
                
                this.actions.set('stopManager', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    await window.executeAgentOperation(agent, 'stop-manager');
                });
                
                this.actions.set('restartManager', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    await window.executeAgentOperation(agent, 'restart-manager');
                });
                
                this.actions.set('reboot', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    await window.executeAgentOperation(agent, 'reboot');
                });
                
                this.actions.set('ssh', async (params) => {
                    if (!params.agent) throw new Error('agent parameter required');
                    const agent = this.findAgent(params.agent);
                    // SSH URL - opens default SSH client
                    const sshUrl = `ssh://root@${agent.ip || agent.name}`;
                    window.open(sshUrl, '_blank');
                    return { opened: true, url: sshUrl };
                });
                
                // Hamburger menu actions
                this.actions.set('startAllAgents', async () => {
                    if (window.startAllAgents) window.startAllAgents();
                });
                
                this.actions.set('stopAllAgents', async () => {
                    if (window.stopAllAgents) window.stopAllAgents();
                });
                
                this.actions.set('startAllManagers', async () => {
                    if (window.startAllManagers) window.startAllManagers();
                });
                
                this.actions.set('stopAllManagers', async () => {
                    if (window.stopAllManagers) window.stopAllManagers();
                });
                
                // Button actions
                this.actions.set('clickButton', async (params) => {
                    if (!params.selector) throw new Error('selector parameter required');
                    const button = document.querySelector(params.selector);
                    if (button && !button.disabled) {
                        button.click();
                    } else {
                        throw new Error('Button not found or disabled');
                    }
                });
                
                // Tab actions
                this.actions.set('switchTab', async (params) => {
                    if (!params.tabId) throw new Error('tabId parameter required');
                    if (typeof switchTab === 'function') {
                        switchTab(params.tabId);
                        return { switched: true, tabId: params.tabId };
                    } else {
                        throw new Error('switchTab function not found');
                    }
                });
                
                // Chat actions
                this.actions.set('sendChat', async (params) => {
                    if (!params.message) throw new Error('message parameter required');
                    const input = document.getElementById('task-input');
                    const sendButton = document.querySelector('.send-button');
                    if (input && sendButton) {
                        input.value = params.message;
                        sendButton.click();
                    } else {
                        throw new Error('Chat input or send button not found');
                    }
                });
                
                this.actions.set('sendChatMessage', async (params) => {
                    if (!params.message) throw new Error('message parameter required');
                    const input = document.getElementById('task-input');
                    const sendButton = document.querySelector('.send-button');
                    if (input && sendButton) {
                        input.value = params.message;
                        sendButton.click();
                        return { success: true, message: 'Chat message sent' };
                    } else {
                        throw new Error('Chat input or send button not found');
                    }
                });
                
                this.actions.set('sendMessage', async (params) => {
                    if (!params.tabId) throw new Error('tabId parameter required');
                    if (typeof sendMessage === 'function') {
                        sendMessage(params.tabId);
                        return { sent: true };
                    } else {
                        throw new Error('sendMessage function not found');
                    }
                });
                
                // Console actions
                this.actions.set('toggleConsole', async () => {
                    if (typeof toggleConsole === 'function') {
                        toggleConsole();
                        return { toggled: true };
                    } else {
                        throw new Error('toggleConsole function not found');
                    }
                });
                
                this.actions.set('retryCommand', async (params) => {
                    if (!params.correlationId) throw new Error('correlationId parameter required');
                    const retryButton = document.querySelector(`[data-correlation-id="${params.correlationId}"] .retry-button`);
                    if (retryButton) {
                        retryButton.click();
                    } else {
                        throw new Error('Retry button not found');
                    }
                });
                
                // View actions
                this.actions.set('viewLogs', async (params) => {
                    if (!params.correlationId) throw new Error('correlationId parameter required');
                    if (window.viewLogs) {
                        // Use agent from params if provided, otherwise find from command
                        const agent = params.agent || this.findCommand(params.correlationId)?.agent;
                        if (agent) {
                            await window.viewLogs(params.correlationId, agent);
                            return { viewing: true };
                        } else {
                            throw new Error('Agent not found for correlation ID');
                        }
                    } else {
                        throw new Error('viewLogs function not found');
                    }
                });
                
                this.actions.set('getChatLogs', async (params) => {
                    // Get all chat logs, optionally filtered
                    const allLogs = this.getChatActions();
                    let filteredLogs = allLogs;
                    
                    // Apply filters if provided
                    if (params.action) {
                        filteredLogs = filteredLogs.filter(log => log.action === params.action);
                    }
                    if (params.status) {
                        filteredLogs = filteredLogs.filter(log => log.status === params.status);
                    }
                    if (params.limit) {
                        filteredLogs = filteredLogs.slice(0, params.limit);
                    }
                    
                    return {
                        success: true,
                        count: filteredLogs.length,
                        logs: filteredLogs
                    };
                });
                
                // RPC delay management actions
                this.actions.set('getRpcDelay', async (params) => {
                    return {
                        success: true,
                        delay: this.rpcDelay,
                        unit: 'milliseconds',
                        description: `Current RPC UI delay is ${this.rpcDelay}ms`
                    };
                });
                this.actions.get('getRpcDelay').logging = false;
                
                this.actions.set('setRpcDelay', async (params) => {
                    if (params.delay === undefined) {
                        throw new Error('delay parameter required (in milliseconds)');
                    }
                    
                    const oldDelay = this.rpcDelay;
                    this.rpcDelay = parseInt(params.delay);
                    
                    // Store in localStorage for persistence
                    localStorage.setItem('rpcUiDelay', this.rpcDelay.toString());
                    
                    return {
                        success: true,
                        oldDelay: oldDelay,
                        newDelay: this.rpcDelay,
                        description: `RPC UI delay changed from ${oldDelay}ms to ${this.rpcDelay}ms`
                    };
                });
                this.actions.get('setRpcDelay').logging = true;
                
                this.actions.set('getTabs', async (params) => {
                    const tabInfo = [];
                    
                    // Get all open tabs
                    tabs.forEach((tabData, tabId) => {
                        const messageCount = tabData.messages ? tabData.messages.length : 0;
                        const userMessages = tabData.messages ? tabData.messages.filter(m => m.role === 'user').length : 0;
                        const agentMessages = messageCount - userMessages;
                        
                        tabInfo.push({
                            id: tabId,
                            title: tabData.title,
                            created: tabData.created,
                            isActive: tabId === activeTabId,
                            messageCount: messageCount,
                            userMessages: userMessages,
                            agentMessages: agentMessages,
                            // Include agent info if this is an agent-specific chat
                            agent: activeTabAgents[tabId] ? activeTabAgents[tabId][0] : null
                        });
                    });
                    
                    // Sort by creation time (newest first)
                    tabInfo.sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime());
                    
                    return {
                        success: true,
                        activeTabId: activeTabId,
                        tabCount: tabInfo.length,
                        tabs: tabInfo
                    };
                });
                
                this.actions.set('getActiveTab', async (params) => {
                    // Check if we're on the "new" tab
                    if (activeTabId === 'new') {
                        return {
                            success: true,
                            isNewTab: true,
                            id: 'new',
                            title: 'New Task',
                            type: 'new-task-form'
                        };
                    }
                    
                    // Get the active tab data
                    const tabData = tabs.get(activeTabId);
                    if (!tabData) {
                        return {
                            success: false,
                            error: 'Active tab not found'
                        };
                    }
                    
                    // Get message details
                    const messages = tabData.messages || [];
                    const userMessages = messages.filter(m => m.role === 'user').length;
                    const agentMessages = messages.length - userMessages;
                    
                    const includeMessages = params.includeMessages !== false; // Default to true
                    
                    const result = {
                        success: true,
                        isNewTab: false,
                        id: activeTabId,
                        title: tabData.title,
                        created: tabData.created,
                        messageCount: messages.length,
                        userMessages: userMessages,
                        agentMessages: agentMessages,
                        agent: activeTabAgents[activeTabId] ? activeTabAgents[activeTabId][0] : null,
                        // Include last message preview (fixed to use correct properties)
                        lastMessage: messages.length > 0 ? {
                            content: messages[messages.length - 1].content.substring(0, 100),
                            role: messages[messages.length - 1].role,
                            timestamp: messages[messages.length - 1].timestamp
                        } : null
                    };
                    
                    // Include full conversation if requested (default true)
                    if (includeMessages) {
                        result.messages = messages.map(msg => ({
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp,
                            agentInfo: msg.agentInfo
                        }));
                    }
                    
                    return result;
                });
                
                this.actions.set('setActiveTab', async (params) => {
                    if (!params.tabId) throw new Error('tabId parameter required');
                    
                    // Check if the tab exists (including the special 'new' tab)
                    if (params.tabId !== 'new' && !tabs.has(params.tabId)) {
                        return {
                            success: false,
                            error: `Tab '${params.tabId}' not found`
                        };
                    }
                    
                    // Get the previous active tab for the response
                    const previousTabId = activeTabId;
                    
                    // Use the existing switchTab function which handles all the UI updates
                    if (typeof switchTab === 'function') {
                        switchTab(params.tabId);
                    } else {
                        throw new Error('switchTab function not found');
                    }
                    
                    return {
                        success: true,
                        previousTabId: previousTabId,
                        activeTabId: params.tabId,
                        tabTitle: params.tabId === 'new' ? 'New Task' : tabs.get(params.tabId).title
                    };
                });
                this.actions.get('setActiveTab').logging = false;
                
                this.actions.set('viewChatActionLog', async (params) => {
                    if (!params.guid) throw new Error('guid parameter required');
                    
                    const action = this.getChatActionStatus(params.guid);
                    if (!action) {
                        alert('Chat action not found');
                        return { found: false };
                    }
                    
                    // Create a simple modal to show action details
                    const modal = document.createElement('div');
                    modal.className = 'history-modal';
                    modal.style.display = 'block';
                    
                    const resultJson = action.result ? JSON.stringify(action.result, null, 2) : 'No result';
                    const paramsJson = JSON.stringify(action.params, null, 2);
                    
                    modal.innerHTML = `
                        <div class="history-modal-content" style="max-width: 800px;">
                            <div class="history-modal-header">
                                <h3>Chat Action Log: ${action.action}</h3>
                                <span class="history-modal-close" onclick="this.closest('.history-modal').remove()">&times;</span>
                            </div>
                            <div class="history-modal-body" style="max-height: 600px; overflow-y: auto;">
                                <div style="margin-bottom: 20px;">
                                    <strong>GUID:</strong> ${action.guid}<br>
                                    <strong>Action:</strong> ${action.action}<br>
                                    <strong>Tab:</strong> ${action.tabTitle}<br>
                                    <strong>Status:</strong> <span class="${action.status === 'success' ? 'status-completed' : action.status === 'error' ? 'status-failed' : 'status-polling'}">${action.status}</span><br>
                                    <strong>Duration:</strong> ${action.duration ? `${action.duration}ms` : 'N/A'}<br>
                                    <strong>Start Time:</strong> ${new Date(action.startTime).toLocaleString()}
                                </div>
                                
                                <h4>Parameters:</h4>
                                <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px; overflow-x: auto;">${paramsJson}</pre>
                                
                                ${action.error ? `
                                <h4>Error:</h4>
                                <pre style="background: #3e2828; padding: 10px; border-radius: 4px; color: #ff6b6b;">${action.error}</pre>
                                ` : ''}
                                
                                <h4>Result:</h4>
                                <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px; overflow-x: auto;">${resultJson}</pre>
                            </div>
                        </div>
                    `;
                    
                    document.body.appendChild(modal);
                    return { opened: true };
                });
                
                this.actions.set('getLogsForCorrelation', async (params) => {
                    if (!params.correlationId) throw new Error('correlationId parameter required');
                    
                    // Get both UI and backend logs for a correlation ID
                    const uiLogs = hubGuiLog.getLogs({ correlationId: params.correlationId });
                    
                    // Get execution data from stored commands
                    const commands = getStoredCommands ? getStoredCommands() : [];
                    const command = commands.find(cmd => cmd.correlationId === params.correlationId);
                    
                    // Format logs in a readable way
                    const allLogs = [];
                    
                    // Add UI logs
                    uiLogs.forEach(log => {
                        allLogs.push({
                            timestamp: log.datetime,
                            type: 'UI',
                            action: log.action,
                            message: log.description,
                            worker: log.worker
                        });
                    });
                    
                    // Add command execution info if available
                    if (command) {
                        allLogs.push({
                            timestamp: command.startTime,
                            type: 'EXEC',
                            action: 'commandStart',
                            message: `${command.command} on ${command.agent}`,
                            worker: command.agent
                        });
                        
                        if (command.completedTime) {
                            allLogs.push({
                                timestamp: command.completedTime,
                                type: 'EXEC',
                                action: 'commandComplete',
                                message: `Status: ${command.status}, Duration: ${command.duration}`,
                                worker: command.agent
                            });
                        }
                    }
                    
                    // Sort by timestamp
                    allLogs.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
                    
                    return { logs: allLogs, correlationId: params.correlationId };
                });
                
                // Settings/menu actions
                this.actions.set('openHamburgerMenu', async () => {
                    const hamburger = document.querySelector('.hamburger-menu');
                    if (hamburger) {
                        hamburger.click();
                    }
                });
                
                this.actions.set('openSettings', async () => {
                    const settingsButton = document.querySelector('.settings-icon');
                    if (settingsButton) {
                        settingsButton.click();
                    }
                });
                
                // Console management
                this.actions.set('clearConsole', async () => {
                    if (typeof clearConsoleContent === 'function') {
                        clearConsoleContent();
                        return { cleared: true };
                    } else {
                        throw new Error('clearConsoleContent function not found');
                    }
                });
                
                this.actions.set('switchConsoleTab', async (params) => {
                    if (!params.tab) throw new Error('tab parameter required');
                    
                    const validTabs = ['control', 'chat'];
                    if (!validTabs.includes(params.tab)) {
                        throw new Error(`Invalid tab: ${params.tab}. Must be 'control' or 'chat'`);
                    }
                    
                    // Update tab buttons
                    document.querySelectorAll('.console-tab').forEach(tab => {
                        tab.classList.remove('active');
                    });
                    document.getElementById(`${params.tab}-tab`).classList.add('active');
                    
                    // Update tab content
                    document.querySelectorAll('.console-tab-content').forEach(content => {
                        content.classList.remove('active');
                        content.style.display = 'none';
                    });
                    const targetContent = document.getElementById(`${params.tab}-console`);
                    if (targetContent) {
                        targetContent.classList.add('active');
                        targetContent.style.display = 'block';
                    }
                    
                    // Store active tab
                    window.activeConsoleTab = params.tab;
                    localStorage.setItem('activeConsoleTab', params.tab);
                    
                    return { tab: params.tab };
                });
                
                // Browser management
                this.actions.set('refreshBrowser', async (params) => {
                    const delay = params.delay || 1000;
                    
                    // Log that we're about to refresh
                    console.log('[ActionRouter] Browser refresh requested, will refresh in', delay, 'ms');
                    if (typeof hubGuiLog !== 'undefined') {
                        hubGuiLog.log(null, null, 'browser-refresh', `Browser refresh requested, will refresh in ${delay}ms`);
                    }
                    
                    // Store refresh info
                    sessionStorage.setItem('refreshRequested', JSON.stringify({
                        timestamp: new Date().toISOString(),
                        tabId: window.TAB_ID || 'unknown'
                    }));
                    
                    // Force immediate reload if delay is 0
                    if (delay === 0) {
                        console.log('[ActionRouter] Executing browser refresh NOW (immediate)');
                        window.location.reload(true);
                        return { success: true, message: 'Browser refreshing immediately' };
                    }
                    
                    // Schedule the refresh
                    console.log('[ActionRouter] Scheduling browser refresh in', delay, 'ms');
                    setTimeout(() => {
                        console.log('[ActionRouter] Executing browser refresh NOW');
                        window.location.reload(true); // Force reload from server
                    }, delay);
                    
                    return { 
                        success: true, 
                        message: `Browser will refresh in ${delay}ms`
                    };
                });
                
                // Modal actions
                this.actions.set('closeHistoryModal', async () => {
                    if (typeof closeHistoryModal === 'function') {
                        closeHistoryModal();
                        return { closed: true };
                    }
                });
                
                this.actions.set('closeSummaryModal', async () => {
                    if (typeof closeSummaryModal === 'function') {
                        closeSummaryModal();
                        return { closed: true };
                    }
                });
                
                // Markdown and error handling actions
                this.actions.set('switchMarkdownTab', async (params) => {
                    if (!params.messageId || !params.tab) throw new Error('messageId and tab parameters required');
                    if (typeof switchMarkdownTab === 'function') {
                        switchMarkdownTab(params.messageId, params.tab);
                        return { switched: true };
                    } else {
                        throw new Error('switchMarkdownTab function not found');
                    }
                });
                
                this.actions.set('toggleErrorDetails', async (params) => {
                    if (!params.messageId) throw new Error('messageId parameter required');
                    if (typeof toggleErrorDetails === 'function') {
                        toggleErrorDetails(params.messageId);
                        return { toggled: true };
                    } else {
                        throw new Error('toggleErrorDetails function not found');
                    }
                });
                
                // Permission actions
                this.actions.set('proceedWithPermission', async (params) => {
                    if (!params.tabId || !params.agentId || !params.encodedPermissionText) {
                        throw new Error('tabId, agentId, and encodedPermissionText parameters required');
                    }
                    if (typeof proceedWithPermission === 'function') {
                        await proceedWithPermission(params.tabId, params.agentId, params.encodedPermissionText);
                        return { proceeded: true };
                    } else {
                        throw new Error('proceedWithPermission function not found');
                    }
                });
                
                this.actions.set('denyPermission', async (params) => {
                    if (!params.tabId || !params.agentId) {
                        throw new Error('tabId and agentId parameters required');
                    }
                    if (typeof denyPermission === 'function') {
                        denyPermission(params.tabId, params.agentId);
                        return { denied: true };
                    } else {
                        throw new Error('denyPermission function not found');
                    }
                });
                
                // Chat actions with logging configuration
                
                // Non-logging actions (UI manipulation)
                this.actions.set('setTaskDescription', async (params) => {
                    if (!params.value) throw new Error('value parameter required');
                    const element = document.getElementById('task-command');
                    if (!element) throw new Error('Task description field not found');
                    element.value = params.value;
                    element.dispatchEvent(new Event('input', { bubbles: true }));
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                    return { set: true, value: params.value };
                });
                this.actions.get('setTaskDescription').logging = false;
                
                this.actions.set('setTitle', async (params) => {
                    if (!params.value) throw new Error('value parameter required');
                    const element = document.getElementById('task-title');
                    if (!element) throw new Error('Title field not found');
                    element.value = params.value;
                    element.dataset.userModified = 'true';
                    element.dispatchEvent(new Event('input', { bubbles: true }));
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                    return { set: true, value: params.value };
                });
                this.actions.get('setTitle').logging = false;
                
                // Logging actions (meaningful operations)
                this.actions.set('startTask', async (params) => {
                    // Get the form values (they should be passed in params now)
                    const title = params.tabTitle || '';
                    const command = params.initialPrompt || '';
                    
                    // Fallback to reading from form if not in params
                    const titleField = document.getElementById('task-title');
                    const commandField = document.getElementById('task-command');
                    
                    const finalTitle = title || (titleField ? titleField.value.trim() : '');
                    const finalCommand = command || (commandField ? commandField.value.trim() : '');
                    
                    if (!finalTitle || !finalCommand) throw new Error('Title and description are required')
                    
                    // Do exactly what startNewTask() does:
                    // 1. Create new tab
                    const tabId = createTab(finalTitle);
                    
                    // 2. Store the parent correlationId for this tab's task
                    // This will be used to link all subsequent actions as children
                    const parentCorrelationId = params.correlationId; // Set by performChatAction
                    if (parentCorrelationId) {
                        activeTaskCorrelations.set(tabId, parentCorrelationId);
                        
                        // Update the already-stored chat action with the correct tab info
                        window.actionRouter.updateChatAction(parentCorrelationId, {
                            tabId: tabId,
                            tabTitle: finalTitle
                        });
                    }
                    
                    // 3. Clear form if it exists
                    if (titleField) {
                        titleField.value = '';
                        titleField.dataset.userModified = 'false';
                    }
                    if (commandField) {
                        commandField.value = '';
                    }
                    
                    // 4. Send initial message (which will use the parent correlation)
                    sendMessage(tabId, finalCommand);
                    
                    // Return but DON'T mark as complete - leave it pending
                    // The parent action status will be updated when the AI task completes
                    return { 
                        success: true, 
                        tabId: tabId,
                        title: finalTitle,
                        initialPrompt: finalCommand,
                        pending: true  // Signal that this task continues running
                    };
                });
                this.actions.get('startTask').logging = true;
                
                // Non-logging orchestration action
                this.actions.set('newChat', async (params) => {
                    if (!params.initialPrompt || !params.initialPrompt.trim()) {
                        throw new Error('initialPrompt parameter required');
                    }
                    
                    const correlationId = params.correlationId || this.generateGuid();
                    
                    // Switch to new tab (non-logging)
                    await this.actions.get('setActiveTab')({ 
                        tabId: 'new',
                        correlationId: correlationId
                    });
                    
                    // Fill fields (non-logging)
                    await this.actions.get('setTaskDescription')({ 
                        value: params.initialPrompt,
                        correlationId: correlationId
                    });
                    
                    if (params.title) {
                        await this.actions.get('setTitle')({ 
                            value: params.title,
                            correlationId: correlationId
                        });
                    }
                    
                    // Click Start Task (THIS starts logging as root)
                    // Pass the title and prompt so startTask has them
                    const titleField = document.getElementById('task-title');
                    const commandField = document.getElementById('task-command');
                    const title = titleField ? titleField.value.trim() : (params.title || 'New Task');
                    const command = commandField ? commandField.value.trim() : params.initialPrompt;
                    
                    return await this.actions.get('startTask')({
                        correlationId: correlationId,
                        tabTitle: title,
                        initialPrompt: command
                    });
                });
                this.actions.get('newChat').logging = false;
                
                this.actions.set('startAgentChat', async (params) => {
                    if (!params.agentName) throw new Error('agentName parameter required');
                    if (typeof startNewChat === 'function') {
                        startNewChat(params.agentName);
                        return { started: true, agent: params.agentName };
                    } else {
                        throw new Error('startNewChat function not found');
                    }
                });
                this.actions.get('startAgentChat').logging = true;
                
                // Keep the old one for backwards compatibility but mark as deprecated
                this.actions.set('startNewChat', async (params) => {
                    console.warn('startNewChat is deprecated, use startAgentChat instead');
                    return await this.actions.get('startAgentChat')(params);
                });
                this.actions.get('startNewChat').logging = false;
                
                this.actions.set('reopenChatFromLog', async (params) => {
                    if (!params.filePath) throw new Error('filePath parameter required');
                    if (typeof reopenChatFromLog === 'function') {
                        await reopenChatFromLog(params.filePath);
                        return { reopened: true };
                    } else {
                        throw new Error('reopenChatFromLog function not found');
                    }
                });
                
                // Generic dialog/modal close actions
                this.actions.set('closeDialog', async (params) => {
                    if (!params.element) throw new Error('element parameter required');
                    const overlay = params.element.closest('.dialog-overlay');
                    if (overlay) {
                        overlay.remove();
                        return { closed: true };
                    } else {
                        throw new Error('Dialog overlay not found');
                    }
                });
                
                this.actions.set('closeModal', async (params) => {
                    if (!params.element) throw new Error('element parameter required');
                    const modal = params.element.closest('.modal');
                    if (modal) {
                        modal.remove();
                        return { closed: true };
                    } else {
                        throw new Error('Modal not found');
                    }
                });
                
                // Tab management
                this.actions.set('closeTab', async (params) => {
                    if (!params.tabId) throw new Error('tabId parameter required');
                    if (typeof closeTab === 'function') {
                        closeTab(params.tabId);
                        return { closed: true };
                    }
                });
                
                // Quick actions for chat
                this.actions.set('quickAction', async (params) => {
                    if (!params.action || !params.tabId) throw new Error('action and tabId parameters required');
                    if (typeof quickAction === 'function') {
                        quickAction(params.action, params.tabId);
                        return { executed: true };
                    }
                });
                
                // Copy message content
                this.actions.set('copyMessage', async (params) => {
                    if (!params.messageId) throw new Error('messageId parameter required');
                    if (typeof copyMessageContent === 'function') {
                        copyMessageContent(params.messageId);
                        return { copied: true };
                    }
                });
                
                // Command confirmation
                this.actions.set('confirmCommand', async (params) => {
                    if (!params.tabId || !params.request) throw new Error('tabId and request parameters required');
                    if (typeof confirmCommand === 'function') {
                        confirmCommand(params.tabId, params.request);
                        return { confirmed: true };
                    }
                });
                
                this.actions.set('cancelCommand', async (params) => {
                    if (!params.tabId) throw new Error('tabId parameter required');
                    if (typeof cancelCommand === 'function') {
                        cancelCommand(params.tabId);
                        return { cancelled: true };
                    }
                });
                
                // UI Control Actions for Testing and Automation
                this.actions.set('setValue', async (params) => {
                    if (!params.selector || params.value === undefined) {
                        throw new Error('selector and value parameters required');
                    }
                    const element = document.querySelector(params.selector);
                    if (!element) {
                        throw new Error(`Element not found: ${params.selector}`);
                    }
                    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                        element.value = params.value;
                        // Trigger input event for any listeners
                        element.dispatchEvent(new Event('input', { bubbles: true }));
                        element.dispatchEvent(new Event('change', { bubbles: true }));
                        return { 
                            set: true, 
                            selector: params.selector, 
                            value: params.value,
                            element: element.tagName.toLowerCase()
                        };
                    } else if (element.tagName === 'SELECT') {
                        element.value = params.value;
                        element.dispatchEvent(new Event('change', { bubbles: true }));
                        return { 
                            set: true, 
                            selector: params.selector, 
                            value: params.value,
                            element: 'select'
                        };
                    } else {
                        throw new Error(`Cannot set value on ${element.tagName} element`);
                    }
                });
                
                this.actions.set('getValue', async (params) => {
                    if (!params.selector) throw new Error('selector parameter required');
                    const element = document.querySelector(params.selector);
                    if (!element) {
                        throw new Error(`Element not found: ${params.selector}`);
                    }
                    if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA' || element.tagName === 'SELECT') {
                        return { 
                            value: element.value,
                            selector: params.selector,
                            element: element.tagName.toLowerCase()
                        };
                    } else {
                        return {
                            text: element.textContent,
                            html: element.innerHTML,
                            selector: params.selector,
                            element: element.tagName.toLowerCase()
                        };
                    }
                });
                
                this.actions.set('click', async (params) => {
                    if (!params.selector) throw new Error('selector parameter required');
                    const element = document.querySelector(params.selector);
                    if (!element) {
                        throw new Error(`Element not found: ${params.selector}`);
                    }
                    element.click();
                    return { 
                        clicked: true, 
                        selector: params.selector,
                        element: element.tagName.toLowerCase(),
                        text: element.textContent || element.value || ''
                    };
                });
                
                this.actions.set('submitForm', async (params) => {
                    if (!params.selector) throw new Error('selector parameter required');
                    const form = document.querySelector(params.selector);
                    if (!form) {
                        throw new Error(`Form not found: ${params.selector}`);
                    }
                    if (form.tagName !== 'FORM') {
                        throw new Error(`Element is not a form: ${form.tagName}`);
                    }
                    // Check if form has submit button
                    const submitButton = form.querySelector('[type="submit"], button:not([type="button"])');
                    if (submitButton) {
                        submitButton.click();
                    } else {
                        form.submit();
                    }
                    return { 
                        submitted: true, 
                        selector: params.selector,
                        action: form.action || 'none',
                        method: form.method || 'get'
                    };
                });
                
                this.actions.set('getElements', async (params) => {
                    if (!params.selector) throw new Error('selector parameter required');
                    const elements = document.querySelectorAll(params.selector);
                    const results = [];
                    elements.forEach((el, index) => {
                        results.push({
                            index: index,
                            tag: el.tagName.toLowerCase(),
                            id: el.id || null,
                            class: el.className || null,
                            text: el.textContent?.substring(0, 100) || '',
                            value: (el.value !== undefined) ? el.value : null,
                            href: el.href || null,
                            visible: el.offsetParent !== null
                        });
                    });
                    return { 
                        count: elements.length,
                        selector: params.selector,
                        elements: results
                    };
                });
                
                this.actions.set('waitForElement', async (params) => {
                    if (!params.selector) throw new Error('selector parameter required');
                    const timeout = params.timeout || 5000;
                    const interval = params.interval || 100;
                    const startTime = Date.now();
                    
                    return new Promise((resolve, reject) => {
                        const checkElement = () => {
                            const element = document.querySelector(params.selector);
                            if (element) {
                                resolve({
                                    found: true,
                                    selector: params.selector,
                                    waitTime: Date.now() - startTime,
                                    element: element.tagName.toLowerCase()
                                });
                            } else if (Date.now() - startTime > timeout) {
                                reject(new Error(`Timeout waiting for element: ${params.selector}`));
                            } else {
                                setTimeout(checkElement, interval);
                            }
                        };
                        checkElement();
                    });
                });
                
                this.actions.set('screenshotElement', async (params) => {
                    if (!params.selector) throw new Error('selector parameter required');
                    const element = document.querySelector(params.selector);
                    if (!element) {
                        throw new Error(`Element not found: ${params.selector}`);
                    }
                    const rect = element.getBoundingClientRect();
                    return {
                        selector: params.selector,
                        dimensions: {
                            x: rect.x,
                            y: rect.y,
                            width: rect.width,
                            height: rect.height,
                            top: rect.top,
                            left: rect.left
                        },
                        visible: rect.width > 0 && rect.height > 0
                    };
                });
                
                this.actions.set('refresh', async (params) => {
                    window.location.reload();
                    return { refreshing: true };
                });
            }
            
            findAgent(agentName) {
                const agents = window.agentsData || [];
                const agent = agents.find(a => a.name === agentName);
                if (!agent) {
                    throw new Error(`Agent ${agentName} not found`);
                }
                return agent;
            }
            
            findCommand(correlationId) {
                const commands = getStoredCommands();
                return commands.find(c => c.correlationId === correlationId);
            }
            
            generateGuid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
            
            async performControlAction(action, params = {}) {
                const startTime = Date.now();
                const guid = params.guid || this.generateGuid();
                const mode = params.mode || 'async'; // 'async' or 'waitFor'
                const timeout = params.timeout || 30000; // 30 seconds default
                
                // Apply RPC delay if this is an RPC call (not from UI)
                if (this.isRpcCall && this.rpcDelay > 0) {
                    console.log(`[RPC Delay] Waiting ${this.rpcDelay}ms before action: ${action}`);
                    await new Promise(resolve => setTimeout(resolve, this.rpcDelay));
                }
                
                // Get current tab info (use params.tabTitle if provided for new tabs)
                const activeTab = tabs.get(activeTabId);
                const tabTitle = params.tabTitle || (activeTab ? activeTab.title : 'Unknown');
                
                // Create chat action entry
                // Clean up params by removing internal properties
                const cleanParams = { ...params };
                delete cleanParams.guid;
                delete cleanParams.mode;
                delete cleanParams.timeout;
                
                const chatAction = {
                    guid,
                    action,
                    params: cleanParams,
                    status: 'pending',
                    startTime,
                    tabId: activeTabId,
                    tabTitle,
                    result: null,
                    error: null,
                    duration: null
                };
                
                // Control actions should not be stored in chat log
                // Only chat-specific actions go to chat log
                
                console.log(`[ActionRouter] Performing action: ${action} (${mode} mode, guid: ${guid})`, params);
                
                const handler = this.actions.get(action);
                if (!handler) {
                    const error = `Unknown action: ${action}`;
                    this.updateChatAction(guid, { status: 'error', error, duration: Date.now() - startTime });
                    if (mode === 'waitFor') {
                        throw new Error(error);
                    }
                    return { success: false, guid, error };
                }
                
                if (mode === 'async') {
                    // Async mode - execute in background and return immediately
                    this.executeActionAsync(guid, action, handler, params, startTime);
                    return { success: true, guid, status: 'pending' };
                } else {
                    // WaitFor mode - wait for completion
                    try {
                        const result = await Promise.race([
                            handler(params),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Action timeout')), timeout)
                            )
                        ]);
                        
                        const duration = Date.now() - startTime;
                        this.updateChatAction(guid, { 
                            status: 'success', 
                            result, 
                            duration 
                        });
                        
                        console.log(`[ActionRouter] Action ${action} completed successfully in ${duration}ms`);
                        return { success: true, guid, result, duration };
                    } catch (error) {
                        const duration = Date.now() - startTime;
                        this.updateChatAction(guid, { 
                            status: 'error', 
                            error: error.message, 
                            duration 
                        });
                        
                        console.error(`[ActionRouter] Action ${action} failed:`, error);
                        return { success: false, guid, error: error.message, duration };
                    }
                }
            }
            
            async executeActionAsync(guid, action, handler, params, startTime) {
                try {
                    const result = await handler(params);
                    const duration = Date.now() - startTime;
                    this.updateChatAction(guid, { 
                        status: 'success', 
                        result, 
                        duration 
                    });
                    console.log(`[ActionRouter] Action ${action} completed successfully in ${duration}ms (async)`);
                } catch (error) {
                    const duration = Date.now() - startTime;
                    this.updateChatAction(guid, { 
                        status: 'error', 
                        error: error.message, 
                        duration 
                    });
                    console.error(`[ActionRouter] Action ${action} failed (async):`, error);
                }
            }
            
            async performChatAction(action, params = {}) {
                const startTime = Date.now();
                
                // Apply RPC delay if this is an RPC call (not from UI)
                // Apply delay to EVERY action when isRpcCall is true
                if (this.isRpcCall && this.rpcDelay > 0 && action !== 'getRpcDelay') {
                    console.log(`[RPC Delay] Waiting ${this.rpcDelay}ms before action: ${action}`);
                    await new Promise(resolve => setTimeout(resolve, this.rpcDelay));
                }
                
                // Handle correlationID flow
                let correlationId = params.correlationId;
                const handler = this.actions.get(action);
                
                if (!handler) {
                    // If no action handler, just log it
                    return { success: true, logged: true };
                }
                
                // Check if this action should start logging
                const shouldLog = handler.logging === true;
                const isNewRoot = shouldLog && !correlationId;
                
                // Generate correlationId if this is a new root logging action
                if (isNewRoot) {
                    correlationId = this.generateGuid();
                }
                
                // Get current tab info (use params.tabTitle if provided for new tabs)
                const activeTab = tabs.get(activeTabId);
                const tabTitle = params.tabTitle || (activeTab ? activeTab.title : 'Unknown');
                
                let result = { success: false };
                let error = null;
                
                // Execute the action
                try {
                    // Pass correlationId to sub-actions
                    const actionParams = { ...params, correlationId };
                    result = await handler(actionParams);
                    result.success = true;
                } catch (e) {
                    error = e.message || String(e);
                    result = { success: false, error };
                }
                
                // Only log if this action has logging enabled
                if (shouldLog) {
                    // Clean up params by removing internal properties
                    const cleanParams = { ...params };
                    delete cleanParams.guid;
                    delete cleanParams.correlationId;
                    
                    // Determine status based on result and error presence
                    let status;
                    if (action === 'startTask' && result.pending) {
                        status = 'pending';
                    } else if (result.error || (result.success === false && result.error)) {
                        status = 'error';
                    } else if (result.success) {
                        status = 'success';
                    } else {
                        status = 'error';
                    }
                    
                    const chatAction = {
                        guid: correlationId,
                        correlationId: correlationId,
                        action,
                        params: cleanParams,
                        status: status,
                        startTime,
                        endTime: status === 'pending' ? null : Date.now(),
                        tabId: activeTabId,
                        tabTitle,
                        isRoot: isNewRoot,
                        parentId: isNewRoot ? null : params.correlationId,
                        details: params.details || null,
                        result: result.success ? result : undefined,
                        error: error
                    };
                    
                    // Store in chat log
                    this.storeChatAction(chatAction);
                    
                    console.log(`[ActionRouter] Chat action ${result.success ? 'executed' : 'failed'}: ${action} (${isNewRoot ? 'ROOT' : 'SUB'})`, params);
                } else {
                    // Non-logging action, just pass through
                    console.log(`[ActionRouter] Non-logging action executed: ${action}`, params);
                }
                
                return { ...result, correlationId };
            }
            
            storeChatAction(chatAction) {
                chatActions.push(chatAction);
                if (typeof renderChatConsole === 'function') {
                    renderChatConsole();
                }
            }
            
            updateChatAction(guid, updates) {
                const index = chatActions.findIndex(a => a.guid === guid);
                if (index !== -1) {
                    chatActions[index] = { ...chatActions[index], ...updates };
                    if (typeof renderChatConsole === 'function') {
                        renderChatConsole();
                    }
                }
            }
            
            getChatActions() {
                return [...chatActions];
            }
            
            getChatActionStatus(guid) {
                const action = chatActions.find(a => a.guid === guid);
                return action || null;
            }
        }
        
        // Initialize action router
        const actionRouter = new ActionRouter();
        window.actionRouter = actionRouter; // Make globally accessible for RPC
        
        // Load saved RPC delay from localStorage
        const savedDelay = localStorage.getItem('rpcUiDelay');
        if (savedDelay) {
            actionRouter.rpcDelay = parseInt(savedDelay);
            console.log(`[RPC] Loaded saved UI delay: ${actionRouter.rpcDelay}ms`);
        }
        
        console.log(`CACHE BUST: Loading v${HUB_VERSION} - Fixed: Console updates only from worker callbacks at`, new Date().toISOString());
        console.log(`[TAB] Tab ID: ${TAB_ID}`);
        console.log(`[BrowserRequest] Handler initialized`);
        
        // Check if this is a refresh that was requested
        const refreshRequested = sessionStorage.getItem('refreshRequested');
        if (refreshRequested) {
            try {
                const refreshData = JSON.parse(refreshRequested);
                const timeSinceRequest = Date.now() - new Date(refreshData.timestamp).getTime();
                if (timeSinceRequest < 60000) { // Within last minute
                    hubGuiLog.log(null, null, 'browser-refreshed', 
                        `Browser refreshed as requested ${timeSinceRequest}ms ago (from tab ${refreshData.tabId})`);
                }
            } catch (e) {
                console.error('Error parsing refresh request data:', e);
            }
            sessionStorage.removeItem('refreshRequested');
        }
        
        // Log hub startup
        hubGuiLog.log(null, null, 'hub-startup', `Hub UI loaded, version ${HUB_VERSION}, tab ${TAB_ID}`);
        
        const API_BASE = window.location.origin + '/api';
        let selectedAgents = [];
        let activeTabId = 'new';
        let tabs = new Map(); // tabId -> { title, messages, agentInfo }
        let activeTabAgents = {}; // tabId -> [agentName] mapping for chat tabs
        let chatHistory = []; // Persistent storage of all chats
        let activeChats = {}; // tabId -> chatId mapping for logging
        
        // Clear all tab data on page load (fresh start for each browser instance)
        function clearAllTabs() {
            tabs.clear();
            activeTabAgents = {};
            activeChats = {};
            // Keep chatHistory for persistence but clear active tabs
            hubGuiLog.log(null, null, 'tabs-cleared', 'All tabs cleared on browser refresh');
        }
        let previousAgentStates = new Map(); // Track previous agent states for change detection
        const MAX_TABS = 5;
        
        // Helper function for safe JSON parsing with detailed error logging
        async function safeJsonParse(response, context = '') {
            const responseText = await response.text();
            try {
                return JSON.parse(responseText);
            } catch (e) {
                console.error(`Error parsing JSON ${context}:`, e);
                console.error('Raw response that failed to parse:', responseText);
                console.error('Response length:', responseText.length);
                console.error('First 500 chars:', responseText.substring(0, 500));
                
                // Try to identify the problematic character
                if (e.message && e.message.includes('position')) {
                    const match = e.message.match(/position (\d+)/);
                    if (match) {
                        const position = parseInt(match[1]);
                        const start = Math.max(0, position - 50);
                        const end = Math.min(responseText.length, position + 50);
                        console.error(`Characters around position ${position}:`, responseText.substring(start, end));
                        console.error(`Character at position ${position}:`, responseText.charCodeAt(position));
                        console.error(`Hex value at position ${position}:`, '0x' + responseText.charCodeAt(position).toString(16));
                    }
                }
                
                // Return error details for UI display
                throw {
                    message: e.message,
                    responseText: responseText,
                    originalError: e
                };
            }
        }
        
        // Tab management
        function generateTabId() {
            return 'tab-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }
        
        function createTab(title, initialMessage, customTabId = null) {
            const tabId = customTabId || generateTabId();
            
            // Log tab creation
            hubGuiLog.log(null, null, 'tab-created', 
                `User created new tab: ${title} (${tabId})`);
            
            // Check if we need to close oldest tab
            if (tabs.size >= MAX_TABS) {
                const oldestTab = Array.from(tabs.keys())[0];
                closeTab(oldestTab);
            }
            
            // Create tab data
            tabs.set(tabId, {
                title: title,
                messages: [],
                created: new Date()
            });
            
            // Create tab element
            const tabBar = document.getElementById('tab-bar');
            const newTab = document.createElement('div');
            newTab.className = 'tab';
            newTab.dataset.tabId = tabId;
            newTab.innerHTML = `
                <span class="tab-title">${title}</span>
                <span class="tab-close" onclick="event.stopPropagation(); window.performControlAction('closeTab', {tabId: '${tabId}'})">×</span>
            `;
            newTab.onclick = () => switchTab(tabId);
            
            // Insert before the "+ New Chat" tab
            const newChatTab = tabBar.querySelector('.new-chat');
            tabBar.insertBefore(newTab, newChatTab);
            
            // Create chat container
            const container = document.createElement('div');
            container.className = 'chat-container';
            container.dataset.tabId = tabId;
            container.innerHTML = `
                <div class="chat-messages" id="messages-${tabId}"></div>
                <div class="chat-input-container">
                    <div class="quick-actions">
                        <div class="quick-action" onclick="window.performControlAction('quickAction', {action: 'Check status', tabId: '${tabId}'})">Check status</div>
                        <div class="quick-action" onclick="window.performControlAction('quickAction', {action: 'Show logs', tabId: '${tabId}'})">Show logs</div>
                        <div class="quick-action" onclick="window.performControlAction('quickAction', {action: 'List services', tabId: '${tabId}'})">List services</div>
                    </div>
                    <div class="input-wrapper">
                        <textarea 
                            id="input-${tabId}"
                            class="chat-input" 
                            placeholder="Continue the conversation..."
                            rows="1"
                            onkeydown="handleInputKeydown(event, '${tabId}')"
                        ></textarea>
                        <button class="send-button" onclick="window.performControlAction('sendMessage', {tabId: '${tabId}'})">
                            Send →
                        </button>
                    </div>
                </div>
            `;
            
            document.getElementById('chat-containers').appendChild(container);
            
            // Switch to new tab
            switchTab(tabId);
            
            // Start chat logging (but not for agent detail pages)
            if (!customTabId || !customTabId.includes('agent-') || !customTabId.includes('-details')) {
                startChatLogging(tabId, title);
            }
            
            // Add initial message if provided
            if (initialMessage) {
                sendMessage(tabId, initialMessage);
            }
            
            return tabId;
        }
        
        function switchTab(tabId) {
            // Log tab switch
            const tabTitle = tabs.get(tabId)?.title || 'New Task';
            hubGuiLog.log(null, null, 'tab-switch', 
                `User switched to tab: ${tabTitle} (${tabId})`);
            
            // Update active tab state
            activeTabId = tabId;
            
            // Update tab styling
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tabId === tabId);
            });
            
            // Show/hide chat containers
            document.querySelectorAll('.chat-container').forEach(container => {
                container.style.display = container.dataset.tabId === tabId ? 'flex' : 'none';
            });
            
            // Focus input if not new chat tab
            if (tabId !== 'new') {
                setTimeout(() => {
                    const input = document.getElementById(`input-${tabId}`);
                    if (input) input.focus();
                }, 100);
            } else {
                // Reset the userModified flag when switching to new tab
                const titleInput = document.getElementById('task-title');
                if (titleInput) {
                    titleInput.dataset.userModified = 'false';
                }
                // Focus the command textarea
                setTimeout(() => {
                    const commandInput = document.getElementById('task-command');
                    if (commandInput) commandInput.focus();
                }, 100);
            }
        }
        
        function closeTab(tabId) {
            if (!tabs.has(tabId)) return;
            
            // Save to history
            const tabData = tabs.get(tabId);
            
            // Log tab closure
            hubGuiLog.log(null, null, 'tab-closed', 
                `User closed tab: ${tabData.title} (${tabId})`);
            
            chatHistory.push({
                id: tabId,
                title: tabData.title,
                messages: tabData.messages,
                created: tabData.created,
                closed: new Date()
            });
            
            // Stop chat logging
            closeChatLogging(tabId);
            
            // Remove tab
            tabs.delete(tabId);
            
            // Remove DOM elements
            document.querySelector(`[data-tab-id="${tabId}"]`).remove();
            document.querySelector(`.chat-container[data-tab-id="${tabId}"]`).remove();
            
            // Switch to new chat if this was active
            if (activeTabId === tabId) {
                switchTab('new');
            }
            
            // Save history to localStorage
            saveHistory();
        }
        
        // Chat logging functions
        async function startChatLogging(tabId, title, agents = []) {
            try {
                const response = await fetch(`${API_BASE}/chat/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tabId, title, agents })
                });
                const data = await response.json();
                if (data.success) {
                    activeChats[tabId] = data.chatId;
                    console.log(`Started logging for chat ${data.chatId}`);
                }
            } catch (error) {
                console.error('Failed to start chat logging:', error);
            }
        }
        
        async function logChatMessage(tabId, role, text, agentName) {
            if (!activeChats[tabId]) return;
            
            try {
                await fetch(`${API_BASE}/chat/message`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tabId, role, text, agentName })
                });
            } catch (error) {
                console.error('Failed to log message:', error);
            }
        }
        
        async function closeChatLogging(tabId) {
            if (!activeChats[tabId]) return;
            
            try {
                await fetch(`${API_BASE}/chat/close`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tabId })
                });
                delete activeChats[tabId];
            } catch (error) {
                console.error('Failed to close chat logging:', error);
            }
        }
        
        // Message handling
        function addMessage(tabId, content, isUser = false, agentInfo = null, errorDetails = null) {
            const container = document.getElementById(`messages-${tabId}`);
            if (!container) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'ai'}`;
            
            const timestamp = formatTime();
            const messageId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            
            // Check if content looks like an error
            const isError = !isUser && (content.includes('Error:') || content.includes('Failed to process command'));
            
            // Check if content looks like it contains markdown
            const hasMarkdown = !isUser && detectMarkdown(content);
            
            let contentHtml = content;
            if (hasMarkdown) {
                // Create tabbed view for markdown
                const rawContent = content;
                const renderedContent = renderMarkdown(content);
                
                // Log markdown debugging info to chat console
                window.performChatAction('markdownRender', {
                    details: {
                        messageId: messageId,
                        rawLength: rawContent.length,
                        renderedLength: renderedContent.length,
                        hasStrayTags: renderedContent.includes('</pre>') && renderedContent.includes('</div>'),
                        truncatedTable: rawContent.includes('192.168\n\n**Command Output:**')
                    }
                });
                contentHtml = `
                    <div class="markdown-tabs">
                        <div class="tab-buttons">
                            <button class="tab-btn active" onclick="window.performControlAction('switchMarkdownTab', {messageId: '${messageId}', tab: 'rendered'})">Rendered</button>
                            <button class="tab-btn" onclick="window.performControlAction('switchMarkdownTab', {messageId: '${messageId}', tab: 'raw'})">Markdown</button>
                        </div>
                        <div class="tab-content rendered" id="rendered-${messageId}">
                            ${renderedContent}
                        </div>
                        <div class="tab-content raw" id="raw-${messageId}" style="display: none;">
                            <pre>${escapeHtml(rawContent)}</pre>
                        </div>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = `
                <div class="message-avatar">${isUser ? '👤' : '🤖'}</div>
                <div style="flex: 1; position: relative;">
                    <div class="message-content" id="${messageId}">
                        ${contentHtml}
                        ${agentInfo ? `<div class="agent-indicator">→ ${agentInfo}</div>` : ''}
                        ${isError && errorDetails ? `
                            <button class="error-details-btn" onclick="window.performControlAction('toggleErrorDetails', {messageId: '${messageId}'})" title="Show error details">
                                <span style="color: #e74c3c;">❓</span>
                            </button>
                            <div class="error-details" id="error-${messageId}" style="display: none;">
                                <pre>${errorDetails}</pre>
                            </div>
                        ` : ''}
                    </div>
                    <div class="message-time">${timestamp}</div>
                    <button class="copy-btn" onclick="window.performControlAction('copyMessage', {messageId: '${messageId}'})" title="Copy message">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 5H6C5.44772 5 5 5.44772 5 6V20C5 20.5523 5.44772 21 6 21H15C15.5523 21 16 20.5523 16 20V18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                            <path d="M8 5C8 4.44772 8.44772 4 9 4H18C18.5523 4 19 4.44772 19 5V15C19 15.5523 18.5523 16 18 16H9C8.44772 16 8 15.5523 8 15V5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
                </div>
            `;
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
            // Update tab data
            if (tabs.has(tabId)) {
                tabs.get(tabId).messages.push({
                    role: isUser ? 'user' : 'assistant',
                    content: content,
                    agentInfo: agentInfo,
                    timestamp: new Date(),
                    errorDetails: errorDetails
                });
            }
        }
        
        // New task form handling
        async function startNewTask(event) {
            event.preventDefault();
            
            const title = document.getElementById('task-title').value;
            const command = document.getElementById('task-command').value;
            
            if (!title || !command) return;
            
            // Create new tab
            const tabId = createTab(title);
            
            // Clear form
            document.getElementById('task-title').value = '';
            document.getElementById('task-title').dataset.userModified = 'false';
            document.getElementById('task-command').value = '';
            
            // Send initial message
            sendMessage(tabId, command);
        }
        
        // Send message
        async function sendMessage(tabId, messageText = null) {
            const input = document.getElementById(`input-${tabId}`);
            const message = messageText || (input ? input.value.trim() : '');
            
            if (!message) return;
            
            // Add user message
            addMessage(tabId, message, true);
            
            // Log the user message
            await logChatMessage(tabId, 'human', message);
            
            // Clear input
            if (input) {
                input.value = '';
                input.style.height = 'auto';
            }
            
            // Show typing indicator
            showTypingIndicator(tabId);
            
            // Check if this tab has an active parent task correlation
            const parentCorrelationId = activeTaskCorrelations.get(tabId);
            
            // Log console command submission (as child if there's a parent)
            const commandCorrelationId = `chat_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            hubGuiLog.log(null, commandCorrelationId, 'console-command', 
                `User submitted command: ${message.substring(0, 100)}${message.length > 100 ? '...' : ''}`);
            
            // If there's a parent task, log this as a child action
            if (parentCorrelationId && window.actionRouter) {
                const childAction = {
                    guid: commandCorrelationId,
                    correlationId: commandCorrelationId,
                    action: 'sendMessage',
                    params: { message: message.substring(0, 100) + (message.length > 100 ? '...' : '') },
                    status: 'success',
                    startTime: Date.now(),
                    endTime: Date.now(),
                    tabId: tabId,
                    tabTitle: tabs.get(tabId)?.title || 'Unknown',
                    isRoot: false,
                    parentId: parentCorrelationId,
                    isChild: true
                };
                window.actionRouter.storeChatAction(childAction);
            }
            
            try {
                // Get conversation history for this tab
                const tabData = tabs.get(tabId);
                const conversationHistory = tabData ? tabData.messages : [];
                
                // Use tab-specific agents if available, otherwise use globally selected agents
                const tabAgents = activeTabAgents[tabId] || [];
                const targetAgents = tabAgents.length > 0 ? tabAgents : (selectedAgents.length > 0 ? selectedAgents : undefined);
                
                const response = await fetch(`${API_BASE}/command`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        command: message,
                        targetAgents: targetAgents,
                        conversationHistory: conversationHistory,
                        tabId: tabId
                    })
                });
                
                // Better JSON parsing with error details
                const data = await safeJsonParse(response, 'from command endpoint');
                hideTypingIndicator(tabId);
                
                if (data.requiresConfirmation) {
                    // Handle confirmation
                    const confirmHtml = `
                        <p><strong>⚠️ Confirmation Required</strong></p>
                        <p>Risk Level: <span class="risk-${data.risk}">${data.risk.toUpperCase()}</span></p>
                        <p>Action: ${data.interpretation}</p>
                        <p>Target Agents: ${data.targetAgents.join(', ')}</p>
                        <div style="margin-top: 12px;">
                            <button class="send-button" style="margin-right: 8px;" onclick="window.performControlAction('confirmCommand', {tabId: '${tabId}', request: '${data.request}'})">
                                Proceed
                            </button>
                            <button class="send-button" style="background: var(--bg-tertiary);" onclick="window.performControlAction('cancelCommand', {tabId: '${tabId}'})">
                                Cancel
                            </button>
                        </div>
                    `;
                    addMessage(tabId, confirmHtml, false);
                } else if (data.success) {
                    // Display the results immediately (they're included in the response)
                    console.log('Command response data:', data);
                    if (data.results && data.results.length > 0) {
                        // Helper function to extract tabId and clean response
                        function parseResponse(output) {
                            if (!output) return { tabId: null, content: output };
                            
                            const tabMatch = output.match(/^\[TAB:([^\]]+)\]\n/);
                            if (tabMatch) {
                                return {
                                    responseTabId: tabMatch[1],
                                    content: output.substring(tabMatch[0].length)
                                };
                            }
                            return { responseTabId: null, content: output };
                        }
                        
                        // Track which agents responded to this tab
                        const respondingAgents = data.results.map(r => r.agentId).filter((v, i, a) => a.indexOf(v) === i);
                        if (respondingAgents.length > 0) {
                            activeTabAgents[tabId] = respondingAgents;
                            console.log(`Tab ${tabId} now associated with agents:`, respondingAgents);
                        }
                        
                        // Check if this is a conversational response (not a command execution)
                        // Look for natural language patterns or if all results are successful text responses
                        const isConversation = data.results.every(r => r.success && r.output && !r.output.startsWith('CACHE BUST:'));
                        
                        if (isConversation && data.results.length === 1) {
                            // Single agent conversation
                            const result = data.results[0];
                            const { responseTabId, content } = parseResponse(result.output);
                            
                            // Only display if tabId matches or no tabId in response
                            if (!responseTabId || responseTabId === tabId) {
                                const outputHtml = `<div style="margin-bottom: 8px;">
                                    <strong>${result.agentId}:</strong><br>
                                    <pre style="margin-top: 4px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;">${content}</pre>
                                </div>`;
                                addMessage(tabId, outputHtml, false);
                                
                                // Log the assistant response
                                await logChatMessage(tabId, 'assistant', content, result.agentId);
                            } else {
                                console.warn(`Response tabId mismatch: expected ${tabId}, got ${responseTabId}`);
                            }
                            return; // Skip the complex formatting
                        }
                        
                        // Complex response with multiple results or detailed output
                        let resultHtml = '<div style="margin-top: 12px;">';
                        let successCount = 0;
                        
                        data.results.forEach(result => {
                            if (result.success) successCount++;
                            
                            resultHtml += `<div style="margin-bottom: 8px; padding: 8px; background: ${result.success ? 'rgba(39, 174, 96, 0.1)' : 'rgba(231, 76, 60, 0.1)'}; border-radius: 4px;">`;
                            resultHtml += `<strong>${result.agentId}</strong>: ${result.success ? '✅ Success' : '❌ Failed'}<br>`;
                            if (result.output || result.error) {
                                const rawOutput = result.output || result.error;
                                const { responseTabId, content: output } = parseResponse(rawOutput);
                                
                                // Skip if tabId doesn't match
                                if (responseTabId && responseTabId !== tabId) {
                                    console.warn(`Skipping response for wrong tab: expected ${tabId}, got ${responseTabId}`);
                                    return;
                                }
                                
                                // Check for permission markers in the output
                                const permissionMatch = output.match(/\[PERMISSION_REQUIRED:\s*risk=(\w+)\]([\s\S]*?)\[\/PERMISSION_REQUIRED\]/);
                                if (permissionMatch) {
                                    const risk = permissionMatch[1];
                                    const permissionText = permissionMatch[2].trim();
                                    const beforePermission = output.substring(0, output.indexOf('[PERMISSION_REQUIRED'));
                                    const afterPermission = output.substring(output.indexOf('[/PERMISSION_REQUIRED]') + 21);
                                    
                                    // Display the response with permission UI
                                    resultHtml += `<div style="margin-top: 4px;">`;
                                    if (beforePermission.trim()) {
                                        resultHtml += `<pre style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;">${beforePermission.trim()}</pre>`;
                                    }
                                    resultHtml += `
                                        <div style="margin: 8px 0; padding: 12px; background: rgba(231, 76, 60, 0.1); border-radius: 4px; border-left: 4px solid rgba(231, 76, 60, 0.5);">
                                            <p><strong>⚠️ Permission Required</strong></p>
                                            <p>Risk Level: <span class="risk-${risk}" style="color: ${risk === 'critical' ? '#e74c3c' : risk === 'high' ? '#e67e22' : risk === 'medium' ? '#f39c12' : '#27ae60'}; font-weight: bold;">${risk.toUpperCase()}</span></p>
                                            <p>${permissionText}</p>
                                            <div style="margin-top: 12px;">
                                                <button class="send-button" style="margin-right: 8px;" onclick="window.performControlAction('proceedWithPermission', {tabId: '${tabId}', agentId: '${result.agentId}', encodedPermissionText: '${btoa(permissionText)}'})">
                                                    Proceed
                                                </button>
                                                <button class="send-button" style="background: var(--bg-tertiary);" onclick="window.performControlAction('denyPermission', {tabId: '${tabId}', agentId: '${result.agentId}'})">
                                                    Cancel
                                                </button>
                                            </div>
                                        </div>
                                    `;
                                    if (afterPermission.trim()) {
                                        resultHtml += `<pre style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;">${afterPermission.trim()}</pre>`;
                                    }
                                    resultHtml += `</div>`;
                                } else {
                                    // No permission markers, display normally
                                    resultHtml += `<pre style="margin-top: 4px; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;">${output}</pre>`;
                                }
                            }
                            resultHtml += '</div>';
                        });
                        
                        resultHtml += '</div>';
                        
                        // Add summary at the top
                        const summaryHtml = `<p><strong>Summary:</strong> ${successCount}/${data.results.length} successful</p>`;
                        
                        addMessage(tabId, summaryHtml + resultHtml, false);
                    } else {
                        // Debug: log what we received
                        console.warn('No results to display. Full response data:', data);
                        console.warn('data.results:', data.results);
                        console.warn('data.results length:', data.results ? data.results.length : 'undefined');
                        addMessage(tabId, 'Command sent to agents (check console for response data)', false);
                    }
                } else {
                    // Enhanced error display with details
                    const errorDetails = data.errorDetails || `No additional error details available.\n\nResponse data:\n${JSON.stringify(data, null, 2)}`;
                    addMessage(tabId, `Error: ${data.error}`, false, null, errorDetails);
                }
            } catch (error) {
                hideTypingIndicator(tabId);
                // Pass full error details including stack trace
                const errorDetails = `${error.name || 'Error'}: ${error.message}\n\nStack trace:\n${error.stack || 'No stack trace available'}`;
                addMessage(tabId, `Error: ${error.message}`, false, null, errorDetails);
            }
        }
        
        // Typing indicator
        function showTypingIndicator(tabId) {
            const container = document.getElementById(`messages-${tabId}`);
            if (!container) return;
            
            const indicator = document.createElement('div');
            indicator.className = 'message ai';
            indicator.id = `typing-${tabId}`;
            indicator.innerHTML = `
                <div class="message-avatar">🤖</div>
                <div class="message-content">
                    <div class="typing-indicator">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                </div>
            `;
            container.appendChild(indicator);
            container.scrollTop = container.scrollHeight;
        }
        
        function hideTypingIndicator(tabId) {
            const indicator = document.getElementById(`typing-${tabId}`);
            if (indicator) indicator.remove();
            
            // Check if this tab has an active parent task to complete
            const parentCorrelationId = activeTaskCorrelations.get(tabId);
            if (parentCorrelationId && window.actionRouter) {
                // Update the parent task status to complete
                window.actionRouter.updateChatAction(parentCorrelationId, {
                    status: 'success',
                    endTime: Date.now()
                });
                
                // Clear the active task correlation for this tab
                activeTaskCorrelations.delete(tabId);
            }
        }
        
        // Check command results - DEPRECATED: Results are now included in the initial response
        // Keeping this function for backwards compatibility, but it's no longer used
        async function checkResults(tabId, requestId) {
            // This function is no longer called as results are returned immediately
            // in the /api/command response
            console.warn('checkResults called but is deprecated');
        }
        
        // Copy message content
        window.copyMessageContent = function(messageId) {
            const messageElement = document.getElementById(messageId);
            if (!messageElement) return;
            
            // Get text content, removing HTML tags but preserving line breaks
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = messageElement.innerHTML
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/<\/p>\s*<p>/gi, '\n\n');
            
            // Remove copy button and error details button from the copy
            const copyBtn = tempDiv.querySelector('.copy-btn');
            const errorBtn = tempDiv.querySelector('.error-details-btn');
            const errorDetails = tempDiv.querySelector('.error-details');
            if (copyBtn) copyBtn.remove();
            if (errorBtn) errorBtn.remove();
            if (errorDetails) errorDetails.remove();
            
            const textContent = tempDiv.textContent || tempDiv.innerText || '';
            
            navigator.clipboard.writeText(textContent).then(() => {
                // Show feedback
                const btn = messageElement.parentElement.querySelector('.copy-btn');
                if (btn) {
                    const originalHTML = btn.innerHTML;
                    btn.innerHTML = '✓';
                    btn.style.color = '#27ae60';
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                        btn.style.color = '';
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy text:', err);
            });
        };
        
        // Toggle error details visibility
        window.toggleErrorDetails = function(messageId) {
            const errorDiv = document.getElementById(`error-${messageId}`);
            if (errorDiv) {
                errorDiv.style.display = errorDiv.style.display === 'none' ? 'block' : 'none';
            }
        };
        
        // Detect if content contains markdown
        function detectMarkdown(text) {
            // Check for common markdown patterns
            const markdownPatterns = [
                /^#{1,6}\s/m,           // Headers
                /\*\*[^*]+\*\*/,        // Bold
                /\*[^*]+\*/,            // Italic
                /\[([^\]]+)\]\([^)]+\)/,// Links
                /^[\*\-]\s/m,           // Lists
                /^\d+\.\s/m,            // Numbered lists
                /^```/m,                // Code blocks
                /`[^`]+`/,              // Inline code
                /^\>\s/m,               // Blockquotes
                /^\|.*\|/m              // Tables
            ];
            
            return markdownPatterns.some(pattern => pattern.test(text));
        }
        
        // Enhanced markdown renderer using marked.js
        function renderMarkdown(text) {
            // Use marked.js for proper markdown rendering with auto-detection
            if (typeof marked !== 'undefined') {
                // Configure marked options for better rendering
                marked.setOptions({
                    breaks: true, // Convert line breaks to <br>
                    gfm: true, // GitHub Flavored Markdown
                    tables: true, // Support tables
                    sanitize: false, // We'll handle escaping ourselves
                    smartLists: true, // Better list handling
                    smartypants: true, // Better typography
                    highlight: function(code, lang) {
                        // Disable syntax highlighting to avoid potential HTML issues
                        // Just escape the code properly
                        return code.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    }
                });
                
                try {
                    // Render markdown to HTML
                    let html = marked.parse(text);
                    
                    // Clean up any stray HTML tags that might have been generated
                    // This is a workaround for potential marked.js issues
                    html = html.replace(/<\/span><\/span>/g, '</span>');
                    html = html.replace(/<span><span>/g, '<span>');
                    
                    // Fix any stray closing tags at the end
                    // Remove trailing </pre> and </div> tags that don't have matching opening tags
                    if (html.includes('</pre>') || html.includes('</div>')) {
                        console.log('Checking for stray HTML tags in markdown output...');
                        const last100 = html.slice(-100);
                        console.log('Last 100 chars:', last100);
                        
                        // Check if the HTML ends with these specific patterns
                        const patterns = [
                            /<\/pre>\s*<\/div>\s*$/,
                            /<\/code>\s*<\/pre>\s*<\/pre>\s*<\/div>/,
                            /<\/pre>\n<\/div>$/
                        ];
                        
                        for (const pattern of patterns) {
                            if (pattern.test(html)) {
                                console.log('Found stray closing tags, cleaning up with pattern:', pattern);
                                html = html.replace(pattern, '');
                                break;
                            }
                        }
                    }
                    
                    // Debug: check what marked.js generated
                    console.log('Marked.js output length:', html.length);
                    console.log('Last 200 chars of marked output:', html.slice(-200));
                    
                    // Check if the markdown ends with a code block
                    if (text.trim().endsWith('```')) {
                        console.log('Markdown ends with code block');
                        // marked.js sometimes adds extra closing tags after code blocks
                        // Remove any </pre></div> that appears after the last </code></pre>
                        const lastCodeBlockEnd = html.lastIndexOf('</code></pre>');
                        if (lastCodeBlockEnd !== -1) {
                            const afterCodeBlock = html.substring(lastCodeBlockEnd + 13); // 13 = length of </code></pre>
                            console.log('Content after last code block:', afterCodeBlock);
                            if (afterCodeBlock.match(/^\s*<\/pre>\s*<\/div>\s*$/)) {
                                console.log('Found stray </pre></div> after code block, removing...');
                                html = html.substring(0, lastCodeBlockEnd + 13);
                            }
                        }
                    }
                    
                    // The real issue: marked.js adds </pre></div> when it encounters truncated tables
                    // Let's search for these tags throughout the HTML, not just at the end
                    const strayTagMatches = html.match(/<\/pre>\s*<\/div>/g);
                    if (strayTagMatches) {
                        console.log(`Found ${strayTagMatches.length} instances of </pre></div> in HTML`);
                        
                        // Log to chat console
                        window.performChatAction('markdown-cleanup', {
                            details: {
                                strayTagCount: strayTagMatches.length,
                                originalHtml: html.slice(-200),
                                patterns: []
                            }
                        });
                        
                        // Remove </pre></div> that appears between tables or sections
                        // This pattern specifically targets the issue we're seeing
                        html = html.replace(/(<\/table>)\s*<\/pre>\s*<\/div>\s*(<p>|<h[1-6]>|<strong>)/g, '$1\n$2');
                        
                        // Also remove </pre></div> that appears after incomplete content
                        // (like "192.168" followed by these tags)
                        html = html.replace(/(\d+\.\d+)\s*<\/pre>\s*<\/div>/g, '$1');
                        
                        // Remove </pre></div> that appears before "Command Output"
                        html = html.replace(/<\/pre>\s*<\/div>\s*(<p><strong>Command Output:<\/strong><\/p>)/g, '$1');
                        
                        // General cleanup: remove any standalone </pre></div> that doesn't have
                        // a matching opening tag nearby
                        let cleaned = html;
                        let iterations = 0;
                        while (iterations < 5) { // Limit iterations to prevent infinite loops
                            const beforeClean = cleaned;
                            // Look for </pre></div> and check if there's an opening <pre> before it
                            cleaned = cleaned.replace(/(^|[^>])<\/pre>\s*<\/div>/g, function(match, prefix) {
                                // Check if there's a <pre> tag in the previous 200 chars
                                const searchStart = Math.max(0, cleaned.lastIndexOf(match) - 200);
                                const previousContent = cleaned.substring(searchStart, cleaned.lastIndexOf(match));
                                if (!previousContent.includes('<pre')) {
                                    console.log('Removing stray </pre></div> without opening tag');
                                    return prefix; // Remove the tags
                                }
                                return match; // Keep them
                            });
                            if (beforeClean === cleaned) break;
                            iterations++;
                        }
                        html = cleaned;
                    }
                    
                    // Debug emoji rendering
                    if (text.includes('🟢') || text.includes('🔴')) {
                        console.log('Original text contains emoji:', text.includes('🟢'), text.includes('🔴'));
                        console.log('HTML contains emoji:', html.includes('🟢'), html.includes('🔴'));
                        console.log('Sample of HTML:', html.substring(0, 500));
                    }
                    
                    return html;
                } catch (e) {
                    console.error('Marked.js parsing error:', e);
                    // Fall back to basic rendering
                }
            }
            
            // Fallback to basic rendering if marked.js isn't loaded or fails
            console.warn('Using basic markdown rendering');
            let html = escapeHtml(text);
            
            // Headers
            html = html.replace(/^#{6}\s(.+)$/gm, '<h6>$1</h6>');
            html = html.replace(/^#{5}\s(.+)$/gm, '<h5>$1</h5>');
            html = html.replace(/^#{4}\s(.+)$/gm, '<h4>$1</h4>');
            html = html.replace(/^#{3}\s(.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^#{2}\s(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#{1}\s(.+)$/gm, '<h1>$1</h1>');
            
            // Bold and italic
            html = html.replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');
            
            // Links
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            // Lists
            html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
            html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
            html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
            
            // Code blocks
            html = html.replace(/```([^`]*)```/gs, '<pre><code>$1</code></pre>');
            
            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Blockquotes
            html = html.replace(/^&gt; (.+)$/gm, '<blockquote>$1</blockquote>');
            
            // Line breaks
            html = html.replace(/\n/g, '<br>');
            
            // Wrap consecutive list items
            html = html.replace(/(<li>.*<\/li>)(<br>)?/g, function(match) {
                return match.replace(/<br>/g, '');
            });
            html = html.replace(/(<li>.*<\/li>)+/g, '<ul>$&</ul>');
            
            return html;
        }
        
        // Escape HTML
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, m => map[m]);
        }
        
        // Switch markdown tab
        window.switchMarkdownTab = function(messageId, tab) {
            const renderedDiv = document.getElementById(`rendered-${messageId}`);
            const rawDiv = document.getElementById(`raw-${messageId}`);
            const buttons = document.querySelectorAll(`#${messageId} .tab-btn`);
            
            if (tab === 'rendered') {
                renderedDiv.style.display = 'block';
                rawDiv.style.display = 'none';
                buttons[0].classList.add('active');
                buttons[1].classList.remove('active');
            } else {
                renderedDiv.style.display = 'none';
                rawDiv.style.display = 'block';
                buttons[0].classList.remove('active');
                buttons[1].classList.add('active');
            }
        };
        
        // Command confirmation handlers
        window.confirmCommand = async function(tabId, request) {
            showTypingIndicator(tabId);
            
            try {
                const response = await fetch(`${API_BASE}/command/confirm`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ request })
                });
                
                const data = await response.json();
                hideTypingIndicator(tabId);
                
                addMessage(tabId, 'Command confirmed and sent!', false);
                setTimeout(() => checkResults(tabId, data.requestId), 2000);
            } catch (error) {
                hideTypingIndicator(tabId);
                // Pass full error details including stack trace
                const errorDetails = `${error.name || 'Error'}: ${error.message}\n\nStack trace:\n${error.stack || 'No stack trace available'}`;
                addMessage(tabId, `Error: ${error.message}`, false, null, errorDetails);
            }
        };
        
        window.cancelCommand = function(tabId) {
            addMessage(tabId, 'Command cancelled.', false);
        };
        
        // Permission handlers for natural language responses
        window.proceedWithPermission = async function(tabId, agentId, encodedPermissionText) {
            const permissionText = atob(encodedPermissionText);
            addMessage(tabId, `✅ Permission granted for ${agentId}. Proceeding with: "${permissionText}"`, false);
            
            // Send a follow-up message to the agent confirming permission
            const selectedAgents = activeTabAgents[tabId] || [];
            showTypingIndicator(tabId);
            
            try {
                const response = await fetch(`${API_BASE}/command`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        command: `Please proceed with the operation you just asked permission for: "${permissionText}". The user has granted permission.`,
                        targetAgents: [agentId]
                    })
                });
                
                const data = await response.json();
                hideTypingIndicator(tabId);
                
                if (data.success && data.results && data.results.length > 0) {
                    data.results.forEach(result => {
                        if (result.output) {
                            addMessage(tabId, `<strong>${result.agentId}:</strong><br><pre style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;">${result.output}</pre>`, false);
                        }
                    });
                } else if (data.error) {
                    addMessage(tabId, `Error: ${data.error}`, false);
                }
            } catch (error) {
                hideTypingIndicator(tabId);
                // Pass full error details including stack trace
                const errorDetails = `${error.name || 'Error'}: ${error.message}\n\nStack trace:\n${error.stack || 'No stack trace available'}`;
                addMessage(tabId, `Error: ${error.message}`, false, null, errorDetails);
            }
        };
        
        window.denyPermission = function(tabId, agentId) {
            addMessage(tabId, `❌ Permission denied for ${agentId}. Operation cancelled.`, false);
            
            // Send a follow-up message to the agent informing about denial
            const selectedAgents = activeTabAgents[tabId] || [];
            showTypingIndicator(tabId);
            
            fetch(`${API_BASE}/command`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    command: 'The user has denied permission for the previous operation. Please suggest alternative approaches or ask if there\'s anything else you can help with.',
                    targetAgents: [agentId]
                })
            }).then(response => response.json())
              .then(data => {
                  hideTypingIndicator(tabId);
                  if (data.success && data.results && data.results.length > 0) {
                      data.results.forEach(result => {
                          if (result.output) {
                              addMessage(tabId, `<strong>${result.agentId}:</strong><br><pre style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; font-size: 13px; white-space: pre-wrap; word-wrap: break-word;">${result.output}</pre>`, false);
                          }
                      });
                  }
              }).catch(error => {
                  hideTypingIndicator(tabId);
                  console.error('Error sending denial message:', error);
              });
        };
        
        // Quick actions
        function quickAction(action, tabId) {
            const input = document.getElementById(`input-${tabId}`);
            if (input) {
                input.value = action;
                input.focus();
            }
        }
        
        // Input handling
        function handleInputKeydown(event, tabId) {
            const input = event.target;
            
            // Auto-resize
            input.style.height = 'auto';
            input.style.height = Math.min(input.scrollHeight, 120) + 'px';
            
            // Send on Enter, new line on Shift+Enter
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage(tabId);
            }
        }
        
        // History modal
        function openHistoryModal() {
            const modal = document.getElementById('history-modal');
            const historyList = document.getElementById('history-list');
            
            // Populate history
            historyList.innerHTML = '';
            
            if (chatHistory.length === 0) {
                historyList.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No chat history yet</p>';
            } else {
                chatHistory.forEach(chat => {
                    const firstMessage = chat.messages.find(m => m.role === 'user');
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    historyItem.innerHTML = `
                        <div class="history-title">${chat.title}</div>
                        <div class="history-preview">${firstMessage ? firstMessage.content.substring(0, 100) + '...' : 'No messages'}</div>
                        <div class="history-meta">
                            Created: ${formatDate(chat.created)} | 
                            Messages: ${chat.messages.length}
                        </div>
                    `;
                    historyItem.onclick = () => reopenChat(chat);
                    historyList.appendChild(historyItem);
                });
            }
            
            modal.classList.add('open');
        }
        
        function closeHistoryModal() {
            document.getElementById('history-modal').classList.remove('open');
        }
        
        function showSummaryModal(title, results, totalDuration) {
            const modal = document.getElementById('summary-modal');
            document.getElementById('summary-title').textContent = title;
            
            // Categorize results
            const successful = results.filter(r => r.status === 'success');
            const alreadyInState = results.filter(r => r.status === 'already');
            const failed = results.filter(r => r.status === 'failed');
            
            let html = '';
            
            // Show total duration at the top
            if (totalDuration) {
                html += '<div style="margin-bottom: 20px; padding: 10px; background-color: rgba(255,255,255,0.05); border-radius: 5px;">';
                html += '<strong>Total time until dialog shown:</strong> ' + (totalDuration / 1000).toFixed(2) + ' seconds';
                html += '</div>';
            }
            
            // Show successful operations
            if (successful.length > 0) {
                html += '<div style="margin-bottom: 20px;">';
                html += '<h3 style="color: var(--success); margin-bottom: 10px;">✅ Successful (' + successful.length + '):</h3>';
                successful.forEach(r => {
                    html += '<div style="padding-left: 20px; margin-bottom: 5px;">• <strong>' + r.agent + '</strong> - ' + r.message;
                    if (r.callbackDuration) {
                        html += ' → <span style="color: var(--success);">' + (r.callbackDuration / 1000).toFixed(2) + 's</span>';
                    } else if (r.duration) {
                        html += ' (' + r.duration + ')';
                    }
                    html += '</div>';
                });
                html += '</div>';
            }
            
            // Show already in state
            if (alreadyInState.length > 0) {
                html += '<div style="margin-bottom: 20px;">';
                html += '<h3 style="color: var(--warning); margin-bottom: 10px;">⚠️ Already ' + (title.includes('Start') ? 'Running' : 'Stopped') + ' (' + alreadyInState.length + '):</h3>';
                alreadyInState.forEach(r => {
                    html += '<div style="padding-left: 20px; margin-bottom: 5px;">• <strong>' + r.agent + '</strong> - No action needed</div>';
                });
                html += '</div>';
            }
            
            // Show failed operations
            if (failed.length > 0) {
                html += '<div style="margin-bottom: 20px;">';
                html += '<h3 style="color: var(--error); margin-bottom: 10px;">❌ Failed - Manager Not Running (' + failed.length + '):</h3>';
                failed.forEach(r => {
                    html += '<div style="padding-left: 20px; margin-bottom: 5px;">• <strong>' + r.agent + '</strong> - ' + r.message + '</div>';
                });
                html += '</div>';
            }
            
            // Add summary line
            const totalAgents = results.length;
            const summaryParts = [];
            if (successful.length > 0) summaryParts.push(successful.length + ' ' + (title.includes('Start') ? 'started' : 'stopped'));
            if (alreadyInState.length > 0) summaryParts.push(alreadyInState.length + ' already ' + (title.includes('Start') ? 'running' : 'stopped'));
            if (failed.length > 0) summaryParts.push(failed.length + ' failed');
            
            html += '<div style="border-top: 1px solid var(--border-color); margin-top: 20px; padding-top: 15px;">';
            html += '<strong>Summary:</strong> ' + summaryParts.join(', ');
            html += '</div>';
            
            document.getElementById('summary-content').innerHTML = html;
            modal.classList.add('open');
        }
        
        function closeSummaryModal() {
            document.getElementById('summary-modal').classList.remove('open');
        }
        
        function reopenChat(chat) {
            closeHistoryModal();
            
            // Create new tab with historical data
            const tabId = createTab(chat.title);
            
            // Restore messages
            const tabData = tabs.get(tabId);
            tabData.messages = [...chat.messages];
            
            // Display all messages
            chat.messages.forEach(msg => {
                addMessage(tabId, msg.content, msg.role === 'user', msg.agentInfo);
            });
        }
        
        // Agent management
        async function loadAgents() {
            try {
                const response = await fetch(`${API_BASE}/agents`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                
                // Store agents globally for command queue
                window.agentsData = data.agents;
                
                const agentsList = document.getElementById('agents-list');
                agentsList.innerHTML = '';
                
                // Update status bar
                const onlineCount = data.agents.filter(a => a.isOnline).length;
                document.getElementById('agent-count').textContent = `${onlineCount}/${data.agents.length}`;
                document.getElementById('last-update').textContent = formatTime(new Date());
                
                if (data.agents.length === 0) {
                    agentsList.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">No agents configured</p>';
                    return;
                }
                
                data.agents.forEach(agent => {
                    // Check for state changes
                    const previousState = previousAgentStates.get(agent.name);
                    const currentState = {
                        agentOnline: agent.isOnline,
                        managerOnline: agent.managerVersion && agent.managerVersion !== 'unknown' && agent.managerVersion !== 'offline',
                        managerVersion: agent.managerVersion || 'unknown'
                    };
                    
                    if (previousState) {
                        // Check for agent status change
                        if (previousState.agentOnline !== currentState.agentOnline) {
                            // Find any recent commands for this agent (pending or success)
                            const commands = getStoredCommands();
                            const recentCommand = commands.find(cmd => 
                                cmd.agent === agent.name && 
                                (cmd.status === 'pending' || cmd.status === 'success') &&
                                !cmd.pollLogged // Haven't logged the poll for this command yet
                            );
                            
                            if (recentCommand) {
                                hubGuiLog.log(agent.name, recentCommand.correlationId, 'poll-detected', 
                                    `5-second poll detected agent status changed to ${currentState.agentOnline ? 'online' : 'offline'}`);
                                // Mark that we've logged the poll for this command
                                recentCommand.pollLogged = true;
                                updateStoredCommands(commands);
                            }
                        }
                        
                        // Check for manager status change
                        if (previousState.managerOnline !== currentState.managerOnline) {
                            // Find any recent commands for this agent's manager (pending or success)
                            const commands = getStoredCommands();
                            const recentCommand = commands.find(cmd => 
                                cmd.agent === agent.name && 
                                (cmd.status === 'pending' || cmd.status === 'success') &&
                                cmd.command.includes('manager') &&
                                !cmd.pollLogged // Haven't logged the poll for this command yet
                            );
                            
                            if (recentCommand) {
                                hubGuiLog.log(agent.name, recentCommand.correlationId, 'poll-detected', 
                                    `5-second poll detected manager status changed to ${currentState.managerOnline ? 'online' : 'offline'}`);
                                // Mark that we've logged the poll for this command
                                recentCommand.pollLogged = true;
                                updateStoredCommands(commands);
                            }
                        }
                    }
                    
                    // Store current state for next comparison
                    previousAgentStates.set(agent.name, currentState);
                    const div = document.createElement('div');
                    div.className = 'agent-item';
                    if (selectedAgents.includes(agent.name)) {
                        div.classList.add('selected');
                    }
                    
                    // Format version display
                    let agentVersion = agent.version || 'unknown';
                    let managerVersion = agent.managerVersion || 'unknown';
                    
                    // Determine statuses
                    const agentOnline = agent.isOnline;
                    // Manager is considered online if we have a valid version string
                    const managerIsUnknown = managerVersion === undefined || managerVersion === 'unknown';
                    const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== 'offline';
                    
                    // Determine overall status color
                    let statusClass = 'offline';
                    if (agentOnline && managerOnline) {
                        statusClass = 'online';
                    } else if (agentOnline || managerOnline) {
                        statusClass = 'warning';
                    }
                    
                    div.innerHTML = `
                        <div class="agent-name">
                            <div>
                                <span class="agent-status-container" title="Agent: ${agentOnline ? 'online' : 'offline'}, Manager: ${managerOnline ? 'online' : managerIsUnknown ? 'unknown' : 'offline'}">
                                    <span class="status-indicator status-${agentOnline ? 'online' : 'offline'}" title="Agent">A</span>
                                    <span class="status-indicator status-${managerOnline ? 'online' : managerIsUnknown ? 'unknown' : 'offline'}" title="Manager">M</span>
                                </span>
                                ${agent.name}
                            </div>
                            <span class="agent-ip">${agent.ip}</span>
                        </div>
                        <div class="agent-versions">
                            <span class="version-left">Agent: ${agentVersion}</span>
                            <span class="version-right">Manager: ${managerVersion}</span>
                        </div>
                        ${agent.lastSeen ? `<div class="agent-details"><small>Last seen: ${formatTime(new Date(agent.lastSeen))}</small></div>` : ''}
                    `;
                    div.onclick = () => showAgentDetails(agent);
                    div.oncontextmenu = (e) => showAgentContextMenu(e, agent);
                    agentsList.appendChild(div);
                });
            } catch (error) {
                console.error('Failed to load agents:', error);
            }
        }
        
        function toggleAgent(agentId, element) {
            const index = selectedAgents.indexOf(agentId);
            if (index > -1) {
                selectedAgents.splice(index, 1);
                element.classList.remove('selected');
                hubGuiLog.log(agentId, null, 'agent-deselected', 
                    `User deselected agent: ${agentId}`);
            } else {
                selectedAgents.push(agentId);
                element.classList.add('selected');
                hubGuiLog.log(agentId, null, 'agent-selected', 
                    `User selected agent: ${agentId}`);
            }
        }
        
        async function showAgentDetails(agent) {
            // Create a special tab for agent details
            const tabId = `agent-${agent.name}-details`;
            
            // Check if details tab already exists
            if (tabs.has(tabId)) {
                switchTab(tabId);
                return;
            }
            
            // Create the details tab
            createTab(`${agent.name} Details`, null, tabId);
            
            // Fetch agent capabilities
            const capabilities = await fetch(`${API_BASE}/capabilities/${agent.name}`).then(r => r.json());
            
            // Get agent config from backend-ai-config.json
            const agentConfig = await fetch(`${API_BASE}/agents`).then(r => r.json())
                .then(data => data.agents.find(a => a.name === agent.name));
            
            // Build detail page HTML
            let detailHtml = `
                <div style="padding: 20px; max-width: 800px;">
                    <h2 style="color: var(--accent-primary); margin-bottom: 20px;">${agent.name}</h2>
                    
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">System Information</h3>
                        <table style="width: 100%; color: var(--text-secondary);">
                            <tr><td><strong>IP Address:</strong></td><td>${agent.ip}</td></tr>
                            <tr><td><strong>Version:</strong></td><td>${agent.version || 'Unknown'}</td></tr>
                            <tr><td><strong>Status:</strong></td><td>${agent.isOnline ? '🟢 Online' : '🔴 Offline'}</td></tr>
                            <tr><td><strong>Platform:</strong></td><td>${agent.platform || 'Unknown'}</td></tr>
                            ${agentConfig ? `<tr><td><strong>Description:</strong></td><td>${agentConfig.description}</td></tr>` : ''}
                        </table>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">Capabilities</h3>
                        ${capabilities.summary ? `<p>${capabilities.summary}</p>` : ''}
                        ${capabilities.modules && capabilities.modules.length > 0 ? `
                            <ul style="margin-top: 10px;">
                                ${capabilities.modules.map(m => `
                                    <li><strong>${m.name}:</strong> ${m.description}</li>
                                `).join('')}
                            </ul>
                        ` : '<p>No documented capabilities</p>'}
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">Recent Chats</h3>
                        <div id="agent-chats-${agent.name}">
                            <p style="color: var(--text-secondary);">Loading chat history...</p>
                        </div>
                    </div>
                    
                    <button class="send-button" onclick="window.performChatAction('startAgentChat', {agentName: '${agent.name}'})" style="margin-top: 20px;">
                        Start New Chat with ${agent.name}
                    </button>
                </div>
            `;
            
            // Add the content to the tab
            const container = document.getElementById(`messages-${tabId}`);
            if (container) {
                container.innerHTML = detailHtml;
                
                // Load chat history asynchronously
                getAgentChats(agent.name).then(chatsHtml => {
                    const chatsContainer = document.getElementById(`agent-chats-${agent.name}`);
                    if (chatsContainer) {
                        chatsContainer.innerHTML = chatsHtml;
                    }
                });
            }
        }
        
        async function getAgentChats(agentName) {
            try {
                // Fetch chat history from the server
                const response = await fetch(`${API_BASE}/chat/agent/${agentName}`);
                const data = await response.json();
                
                if (!data.success || data.chats.length === 0) {
                    return '<p style="color: var(--text-secondary);">No previous chats found</p>';
                }
                
                return data.chats.map(chat => `
                    <div style="padding: 10px; margin: 5px 0; background: var(--bg-primary); border-radius: 4px; cursor: pointer;"
                         onclick="window.performControlAction('reopenChatFromLog', {filePath: '${chat.filePath.replace(/'/g, "\\'")}'})}">
                        <strong>${chat.conversation.name}</strong><br>
                        <small style="color: var(--text-secondary);">
                            ${new Date(chat.conversation.updated_at).toLocaleDateString()} ${new Date(chat.conversation.updated_at).toLocaleTimeString()}
                            - ${chat.messageCount} messages
                        </small>
                        ${chat.firstMessage ? `<div style="color: var(--text-secondary); font-size: 12px; margin-top: 5px;">${chat.firstMessage}...</div>` : ''}
                    </div>
                `).join('');
            } catch (error) {
                console.error('Failed to fetch agent chats:', error);
                return '<p style="color: var(--text-secondary);">Failed to load chat history</p>';
            }
        }
        
        async function reopenChatFromLog(filePath) {
            try {
                // Load the chat from the log file
                const response = await fetch(`${API_BASE}/chat/load?filePath=${encodeURIComponent(filePath)}`);
                const data = await response.json();
                
                if (!data.success) {
                    showErrorDialog('Error', 'Failed to load chat');
                    return;
                }
                
                // Create new tab with historical data
                const tabId = createTab(data.conversation.name);
                
                // Track which agents were involved
                const agents = data.conversation.metadata?.agents || [];
                const messageAgents = [...new Set(data.messages
                    .filter(m => m.metadata?.agentName)
                    .map(m => m.metadata.agentName))];
                activeTabAgents[tabId] = [...new Set([...agents, ...messageAgents])];
                
                // Restore messages
                const tabData = tabs.get(tabId);
                data.messages.forEach(msg => {
                    const content = msg.content[0].text;
                    const isUser = msg.role === 'human';
                    const agentName = msg.metadata?.agentName;
                    
                    // Add to UI
                    addMessage(tabId, content, isUser, agentName);
                    
                    // Don't log these restored messages
                });
                
                // Start logging for new messages in this restored chat
                startChatLogging(tabId, data.conversation.name, activeTabAgents[tabId]);
                
                // Get context for AI (last 10 messages)
                const contextResponse = await fetch(`${API_BASE}/chat/context?filePath=${encodeURIComponent(filePath)}`);
                const contextData = await contextResponse.json();
                
                if (contextData.success) {
                    // Store context info in tab data for when sending new messages
                    tabData.restoredContext = contextData;
                    console.log('Restored context:', contextData);
                }
            } catch (error) {
                console.error('Failed to reopen chat:', error);
                showErrorDialog('Error', 'Failed to load chat history');
            }
        }
        
        function startNewChat(agentName) {
            const tabId = createTab(`Chat with ${agentName}`);
            // Store the agent association
            activeTabAgents[tabId] = [agentName];
        }
        
        // Utility functions
        function formatTime(date = new Date()) {
            // Custom format to remove leading zero from hour and add seconds
            const time = date.toLocaleTimeString('en-US', { 
                hour: 'numeric',  // This removes leading zero
                minute: '2-digit',
                second: '2-digit',
                hour12: true 
            });
            return time;
        }
        
        // Show error dialog
        function showErrorDialog(title, message) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
            `;
            
            // Create dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 24px;
                max-width: 400px;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            `;
            
            dialog.innerHTML = `
                <h3 style="margin: 0 0 16px 0; color: var(--text-primary); font-size: 18px;">${title}</h3>
                <p style="margin: 0 0 24px 0; color: var(--text-secondary); line-height: 1.5;">${message}</p>
                <button style="
                    background: var(--primary-color);
                    color: white;
                    border: none;
                    padding: 8px 24px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 14px;
                    float: right;
                ">Close</button>
            `;
            
            // Add click handler
            const button = dialog.querySelector('button');
            button.onclick = () => {
                overlay.remove();
            };
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
        }
        
        function formatDate(date) {
            return new Date(date).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
        
        // History persistence
        function saveHistory() {
            localStorage.setItem('aiHubChatHistory', JSON.stringify(chatHistory));
        }
        
        function loadHistory() {
            const saved = localStorage.getItem('aiHubChatHistory');
            if (saved) {
                chatHistory = JSON.parse(saved);
            }
        }
        
        // Handle Enter key in form textarea
        function handleFormKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                // Submit the form
                const form = event.target.closest('form');
                if (form) {
                    form.dispatchEvent(new Event('submit', { cancelable: true }));
                }
            }
        }
        
        // Auto-populate title from command text
        function autoPopulateTitle(event) {
            const commandText = event.target.value;
            const titleInput = document.getElementById('task-title');
            
            // Only auto-populate if title is empty or was previously auto-populated
            if (titleInput.dataset.userModified !== 'true') {
                let title = commandText;
                
                // Find first period
                const periodIndex = title.indexOf('.');
                if (periodIndex > 0) {
                    title = title.substring(0, periodIndex);
                }
                
                // Limit to 80 characters
                if (title.length > 80) {
                    title = title.substring(0, 80);
                }
                
                // Trim whitespace
                title = title.trim();
                
                titleInput.value = title;
            }
        }
        
        // Load hub status
        async function loadHubStatus() {
            try {
                const response = await fetch(`${API_BASE}/status`);
                const data = await response.json();
                const managerVersion = data.managerVersion || 'unknown';
                
                // Update the status bar with hub version from const
                const statusSegment = document.querySelector('.status-segment:has(#hub-version)');
                if (statusSegment) {
                    statusSegment.innerHTML = `<span>Hub v${HUB_VERSION}</span>`;
                }
                
                // Handle version-based cache clearing
                const storedVersion = localStorage.getItem('hubVersion');
                if (storedVersion && storedVersion !== HUB_VERSION) {
                    console.log(`Version changed from ${storedVersion} to ${HUB_VERSION}, clearing old localStorage data`);
                    // Console commands now in-memory only
                }
                localStorage.setItem('hubVersion', HUB_VERSION);
                
                console.log(`CACHE BUST: Loading hub v${HUB_VERSION} at`, new Date().toISOString());
            } catch (error) {
                console.error('Failed to load hub status:', error);
            }
        }
        
        // Initialization moved to after console functions are defined
        
        // Context menu handling
        function showAgentContextMenu(event, agent) {
            event.preventDefault();
            event.stopPropagation();
            
            // Remove any existing context menu and overlay
            const existingMenu = document.getElementById('agent-context-menu');
            if (existingMenu) existingMenu.remove();
            const existingOverlay = document.getElementById('context-menu-overlay');
            if (existingOverlay) existingOverlay.remove();
            
            // Create invisible overlay to capture all clicks
            const overlay = document.createElement('div');
            overlay.id = 'context-menu-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 999;
                background: transparent;
            `;
            
            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'agent-context-menu';
            menu.style.cssText = `
                position: fixed;
                left: ${event.clientX}px;
                top: ${event.clientY}px;
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                border-radius: 6px;
                padding: 4px;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            
            // Determine agent and manager states
            const agentOnline = agent.isOnline;
            const managerVersion = agent.managerVersion || agent.manager?.version;
            const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== '';
            
            const operations = [
                { label: 'Start Agent', action: 'startAgent', disabled: agentOnline },
                { label: 'Stop Agent', action: 'stopAgent', disabled: !agentOnline },
                { label: 'Restart Agent', action: 'restartAgent', disabled: !agentOnline },
                { label: '─────────────', action: 'separator' },
                { label: 'Start Manager', action: 'startManager', disabled: managerOnline },
                { label: 'Stop Manager', action: 'stopManager', disabled: !managerOnline },
                { label: 'Restart Manager', action: 'restartManager', disabled: !managerOnline },
                { label: '─────────────', action: 'separator' },
                { label: 'Open SSH', action: 'ssh' },
                { label: 'Reboot Machine', action: 'reboot' }
            ];
            
            operations.forEach(op => {
                const item = document.createElement('div');
                
                if (op.action === 'separator') {
                    item.style.cssText = `
                        height: 1px;
                        background: var(--border-color);
                        margin: 4px 8px;
                    `;
                } else {
                    const isDisabled = op.disabled || false;
                    item.style.cssText = `
                        padding: 8px 16px;
                        cursor: ${isDisabled ? 'not-allowed' : 'pointer'};
                        color: ${isDisabled ? '#666' : 'var(--text-primary)'};
                        opacity: ${isDisabled ? '0.5' : '1'};
                        transition: background 0.2s;
                        border-radius: 4px;
                    `;
                    item.textContent = op.label;
                    
                    if (!isDisabled) {
                        item.onmouseover = () => item.style.background = 'var(--bg-tertiary)';
                        item.onmouseout = () => item.style.background = 'transparent';
                        item.onclick = (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            window.performControlAction(op.action, {agent: agent.name});
                            menu.remove();
                            overlay.remove();
                        };
                    }
                }
                menu.appendChild(item);
            });
            
            // Add overlay first, then menu on top
            document.body.appendChild(overlay);
            document.body.appendChild(menu);
            
            // Close menu when clicking on overlay
            overlay.onclick = (e) => {
                e.stopPropagation();
                e.preventDefault();
                menu.remove();
                overlay.remove();
            };
        }
        
        // Expose globally for command queue
        window.executeAgentOperation = executeAgentOperation;
        window.renderConsoleTable = renderConsoleTable;
        window.renderChatConsole = renderChatConsole;
        
        async function executeAgentOperation(agent, operation) {
            // Validate agent object
            if (!agent || typeof agent !== 'object') {
                console.error('Invalid agent object:', agent);
                alert('Invalid agent object');
                return;
            }
            
            // Check if manager is required for agent operations BEFORE doing anything
            const agentOperations = ['start', 'stop', 'restart'];
            if (agentOperations.includes(operation)) {
                const managerVersion = agent.managerVersion || agent.manager?.version;
                const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== '';
                
                if (!managerOnline) {
                    showErrorDialog('Manager Required', 
                        `The manager must be running to control the agent on ${agent.name}. Please start the manager first.`);
                    return;
                }
            }
            
            const startTime = Date.now();
            
            // Generate correlationId upfront
            const correlationId = `cmd_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Log the user action
            hubGuiLog.log(agent.name, correlationId, operation, 
                `User initiated ${operation} operation on ${agent.name}`);
            
            // Add to console immediately with correlationId
            addConsoleCommand(agent.name, operation, 'pending', correlationId);
            
            // Store correlationId globally for button handlers to capture
            window.lastCorrelationId = correlationId;
            
            try {
                let endpoint;
                let method = 'POST';
                let body = { correlationId }; // Include correlationId in request body
                
                // Map operations to correct endpoints
                switch(operation) {
                    case 'start':
                    case 'stop':
                    case 'restart':
                        // Agent lifecycle operations go through hub API
                        endpoint = `${API_BASE}/agents/${agent.name}/${operation}`;
                        break;
                    case 'startManager':
                        endpoint = `${API_BASE}/managers/${agent.name}/start`;
                        break;
                    case 'stopManager':
                        endpoint = `${API_BASE}/managers/${agent.name}/stop`;
                        break;
                    case 'restart-manager':
                        endpoint = `${API_BASE}/managers/${agent.name}/restart`;
                        break;
                    case 'ssh':
                        // Open SSH in new tab (placeholder)
                        if (!agent || !agent.ip) {
                            console.error('Cannot SSH: agent has no IP address');
                            alert('Cannot SSH: agent has no IP address');
                            return;
                        }
                        window.open(`ssh://${agent.ip}`, '_blank');
                        return;
                    case 'reboot':
                        // Use command endpoint for reboot
                        endpoint = `${API_BASE}/command`;
                        break;
                    default:
                        throw new Error(`Unknown operation: ${operation}`);
                }
                
                // Update body based on operation
                if (operation === 'reboot') {
                    body.command = `reboot ${agent.name}`;
                    body.targetAgents = [agent.name];
                }
                
                const response = await fetch(endpoint, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: Object.keys(body).length > 0 ? JSON.stringify(body) : undefined
                });
                
                const apiTime = Date.now() - startTime;
                const result = await response.json();
                console.log(`Operation ${operation} result:`, result);
                
                // Update the console command with actual API time
                const commands = getStoredCommands();
                const command = commands.find(c => c.correlationId === correlationId);
                if (command) {
                    command.apiTime = `${apiTime}ms`;
                    // Commands already in executionHistory array
                    renderConsoleTable();
                }
                
                if (result.success || response.ok) {
                    let message = `Operation '${operation}' executed on ${agent.name}`;
                    if (operation.includes('manager')) {
                        message = `Manager ${operation.replace('-manager', '')} operation executed on ${agent.name}`;
                        if (result.output) {
                            message += `: ${result.output}`;
                        }
                    }
                    addMessage(activeTabId, message, false);
                    // Refresh agent list after operation
                    setTimeout(loadAgents, 2000);
                } else {
                    addMessage(activeTabId, `Failed to execute '${operation}': ${result.error || result.message}`, false);
                    // Mark command as failed
                    updateCommandStatus(correlationId, { status: 'failed', error: result.error || result.message });
                }
            } catch (error) {
                // Check if this is a connection refused error when trying to manage agent with manager down
                if (error.message.includes('ECONNREFUSED') && 
                    (operation === 'stop' || operation === 'start' || operation === 'restart')) {
                    // Show user-friendly dialog for manager down
                    const dialog = document.createElement('div');
                    dialog.className = 'dialog-overlay';
                    dialog.innerHTML = `
                        <div class="dialog">
                            <h3>❌ Manager Not Available</h3>
                            <div class="dialog-content">
                                <p>Cannot ${operation} the agent on <strong>${agent.name}</strong> because the manager service is not running.</p>
                                <p>The manager service must be running to control agent lifecycle operations.</p>
                                <p style="margin-top: 15px;"><strong>Options:</strong></p>
                                <ul style="text-align: left; margin: 10px 20px;">
                                    <li>Start the manager service first</li>
                                    <li>Use SSH to manually control the agent</li>
                                </ul>
                            </div>
                            <button onclick="window.performControlAction('closeDialog', {element: this})" class="primary-button">OK</button>
                        </div>
                    `;
                    document.body.appendChild(dialog);
                    updateCommandStatus(correlationId, { status: 'failed', error: 'Manager service not available' });
                } else {
                    addMessage(activeTabId, `Error: ${error.message}`, false);
                    // Mark command as failed in console
                    updateCommandStatus(correlationId, { status: 'failed', error: error.message });
                }
            }
        }
        
        // Console management - Chrome DevTools style (in-memory only)
        let consoleVisible = false;
        let executionHistory = []; // In-memory execution history (cleared on refresh)
        let activeCorrelationIds = new Set(); // Track correlationIds from this session only
        
        function initializeConsole() {
            try {
                // Restore console visibility state
                const savedState = localStorage.getItem('consoleVisible');
                if (savedState === 'true') {
                    consoleVisible = true;
                    if (typeof showConsole === 'function') {
                        showConsole();
                    } else {
                        // Fallback for old version
                        const consoleWindow = document.getElementById('console-window');
                        if (consoleWindow) {
                            consoleWindow.style.display = 'block';
                        }
                    }
                } else {
                    // Ensure console starts hidden if not explicitly set to visible
                    consoleVisible = false;
                    if (typeof hideConsole === 'function') {
                        hideConsole();
                    }
                }
                
                // Restore active console tab
                const savedTab = localStorage.getItem('activeConsoleTab') || 'chat';
                window.activeConsoleTab = savedTab;
                if (savedTab === 'chat') {
                    window.performControlAction('switchConsoleTab', { tab: 'chat' });
                }
                
                // Render appropriate console content
                if (savedTab === 'control') {
                    if (typeof window.renderConsoleTable === 'function') {
                        window.renderConsoleTable();
                    } else {
                        console.log('Console command tracking not available in this version');
                    }
                } else {
                    if (typeof renderChatConsole === 'function') {
                        renderChatConsole();
                    }
                }
                
                // Set up periodic refresh for chat console
                if (savedTab === 'chat') {
                    setInterval(() => {
                        if (window.activeConsoleTab === 'chat' && typeof renderChatConsole === 'function') {
                            renderChatConsole();
                        }
                    }, 1000); // Refresh every second to update pending statuses
                }
                
                if (typeof window.restorePolling === 'function') {
                    window.restorePolling();
                }
                
                // Restore timeouts for pending commands
                restorePendingTimeouts();
            } catch (error) {
                console.error('Error initializing console:', error);
                // Clear problematic data
                // Console commands now in-memory only
            }
        }
        
        function toggleConsole() {
            consoleVisible = !consoleVisible;
            localStorage.setItem('consoleVisible', consoleVisible.toString());
            
            if (consoleVisible) {
                showConsole();
            } else {
                hideConsole();
            }
        }
        
        function showConsole() {
            const consoleWindow = document.getElementById('console-window');
            const consoleArrow = document.getElementById('console-arrow');
            
            consoleWindow.classList.add('visible');
            consoleArrow.classList.add('up');
            consoleArrow.textContent = '▼';
            consoleVisible = true;
            document.body.classList.add('console-visible');
        }
        
        function hideConsole() {
            const consoleWindow = document.getElementById('console-window');
            const consoleArrow = document.getElementById('console-arrow');
            
            consoleWindow.classList.remove('visible');
            consoleArrow.classList.remove('up');
            consoleArrow.textContent = '▲';
            consoleVisible = false;
            document.body.classList.remove('console-visible');
        }
        
        // Console command tracking
        let activePollers = new Map(); // Track active polling operations
        let commandTimeouts = new Map(); // Track command timeouts
        
        // Helper functions for status display
        function getStatusColor(status) {
            switch(status) {
                case 'success': return '#27ae60';
                case 'failed': return '#e74c3c';
                case 'timeout': return '#ff9500';
                case 'timeoutSuccess': return '#ffcc02';
                case 'manualTermination': return '#ff9500';
                case 'partialSuccess': return '#ffcc02';
                default: return '#888';
            }
        }
        
        function getStatusSymbol(status) {
            switch(status) {
                case 'success': return '✓ Complete';
                case 'failed': return '✗ Failed';
                case 'timeout': return '⏱ Timeout';
                case 'timeoutSuccess': return '⏱ Timeout (Partial)';
                case 'manualTermination': return '⛔ Terminated';
                case 'partialSuccess': return '⚠ Partial Success';
                default: return '? Unknown';
            }
        }
        
        function getStatusDescription(execution) {
            switch(execution.status) {
                case 'success': 
                    return 'Execution completed successfully';
                case 'failed': 
                    return execution.error || 'Execution failed';
                case 'timeout': 
                    return 'Command timed out without response';
                case 'timeoutSuccess': 
                    return 'Command timed out but partially completed';
                case 'manualTermination': 
                    return 'Command was manually terminated';
                case 'partialSuccess': 
                    return 'Command partially completed with errors';
                default: 
                    return 'Unknown status';
            }
        }
        
        // Function to format timing information
        function formatTimingInfo(execution) {
            const start = new Date(execution.startTime).toLocaleTimeString('en-US', { hour12: false });
            let info = `Start: ${start}`;
            
            if (execution.callbackTime) {
                const callback = new Date(execution.callbackTime).toLocaleTimeString('en-US', { hour12: false });
                const callbackDelay = execution.callbackTime - execution.startTime;
                info += `<br>Callback: ${callback} (+${callbackDelay}ms)`;
            }
            
            if (execution.pollingDetectedTime) {
                const polling = new Date(execution.pollingDetectedTime).toLocaleTimeString('en-US', { hour12: false });
                const pollingDelay = execution.pollingDetectedTime - execution.startTime;
                const afterCallback = execution.callbackTime ? 
                    execution.pollingDetectedTime - execution.callbackTime : null;
                info += `<br>Polling: ${polling} (+${pollingDelay}ms`;
                if (afterCallback !== null) {
                    info += `, ${afterCallback}ms after callback`;
                }
                info += ')';
            }
            
            return info;
        }
        
        // Function to update command timing from correlation tracker
        async function updateCommandTiming(correlationId) {
            if (!correlationId) return;
            
            try {
                const response = await fetch(`/api/executions/${correlationId}`);
                if (response.ok) {
                    const execution = await response.json();
                    const command = consoleCommands.find(cmd => cmd.correlationId === correlationId);
                    if (command) {
                        command.timingInfo = formatTimingInfo(execution);
                        command.status = execution.status || 'pending';
                        updateConsoleDisplay();
                    }
                }
            } catch (error) {
                console.log('Failed to fetch timing info:', error);
            }
        }
        
        function addConsoleCommand(agentName, command, apiTime, correlationId, isChild = false, parentId = null) {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { hour12: true });
            
            // Create initial execution object for timing display
            const initialExecution = {
                correlationId: correlationId,
                startTime: now.getTime(),
                callbackTime: null,
                pollingDetectedTime: null
            };
            
            const commandData = {
                id: correlationId || `cmd_${now.getTime()}_${Math.random().toString(36).substr(2, 9)}`,
                correlationId: correlationId,
                timestamp: now.getTime(),
                time: timeStr,
                agent: agentName,
                command: command,
                timingInfo: formatTimingInfo(initialExecution),
                status: 'pending',
                duration: null,
                isChild: isChild,
                parentId: parentId,
                startTime: now.getTime(),
                callbackTime: null,
                pollingDetectedTime: null,
                completed: false,
                error: null
            };
            
            // Add to in-memory history and track correlationId
            executionHistory.unshift(commandData); // Add to beginning
            activeCorrelationIds.add(correlationId); // Track this session's correlationId
            
            // Add to table
            renderConsoleTable();
            
            // Start listening for execution updates if we have a correlationId
            if (correlationId && !isChild) {
                // Check if this is a parent command (client-side only)
                const isParentCommand = command === 'start-all' || command === 'stop-all' || 
                                      command === 'start-all-managers' || command === 'stop-all-managers';
                
                if (!isParentCommand) {
                    console.log(`[CONSOLE] Starting to listen for updates on ${correlationId}`);
                    listenForExecutionUpdates(correlationId);
                    
                    // Fetch initial execution data to get proper timing info
                    setTimeout(async () => {
                        try {
                            console.log(`[CONSOLE] Fetching initial data for ${correlationId}`);
                            const response = await fetch(`/api/executions/${correlationId}`);
                            if (response.ok) {
                                const execution = await response.json();
                                console.log(`[CONSOLE] Got execution data:`, execution);
                                const commands = getStoredCommands();
                                const command = commands.find(c => c.correlationId === correlationId);
                                if (command) {
                                    command.timingInfo = formatTimingInfo(execution);
                                    command.status = execution.status || 'pending';
                                    
                                    // Update the specific time fields
                                if (execution.callbackTime) {
                                    command.callbackTime = execution.callbackTime;
                                }
                                if (execution.pollingDetectedTime) {
                                    command.pollingDetectedTime = execution.pollingDetectedTime;
                                }
                                
                                if (execution.endTime) {
                                    command.duration = execution.endTime - execution.startTime;
                                }
                                if (execution.error) {
                                    command.error = execution.error;
                                }
                                // Already updating in-memory executionHistory
                                renderConsoleTable();
                                console.log(`[CONSOLE] Updated command with timing info:`, command.timingInfo);
                            }
                        } else {
                            console.log(`[CONSOLE] Failed to fetch execution - status ${response.status}`);
                        }
                    } catch (error) {
                        console.log('Failed to fetch initial timing info:', error);
                    }
                }, 500); // Small delay to ensure execution is tracked
                }
                
                // Set client-side timeout (30 seconds for all operations per STATUS_CHANGE_RULES)
                const timeoutMs = 30000;
                const timeoutId = setTimeout(async () => {
                    console.log(`[TIMEOUT] Command ${correlationId} timed out after ${timeoutMs/1000} seconds`);
                    
                    // Update command status to timeout
                    const commands = getStoredCommands();
                    const timedOutCommand = commands.find(c => c.correlationId === correlationId);
                    if (timedOutCommand) {
                        // For stop operations, attempt force kill
                        if (timedOutCommand.command.includes('stop')) {
                            console.log(`[TIMEOUT] Attempting force kill for ${timedOutCommand.agent}`);
                            try {
                                const serviceType = timedOutCommand.command.includes('manager') ? 'manager' : 'agent';
                                const killResponse = await fetch(`${API_BASE}/agents/${timedOutCommand.agent}/force-kill`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ type: serviceType })
                                });
                                
                                if (killResponse.ok) {
                                    timedOutCommand.status = 'manualTermination';
                                    timedOutCommand.error = 'Service killed via fallback kill script';
                                    console.log(`[TIMEOUT] Force kill successful for ${timedOutCommand.agent}`);
                                } else {
                                    timedOutCommand.status = 'failed';
                                    timedOutCommand.error = 'Timeout - manual intervention required';
                                    console.log(`[TIMEOUT] Force kill failed for ${timedOutCommand.agent}`);
                                }
                            } catch (error) {
                                timedOutCommand.status = 'failed';
                                timedOutCommand.error = 'Timeout - force kill failed';
                                console.error(`[TIMEOUT] Force kill error for ${timedOutCommand.agent}:`, error);
                            }
                        } else {
                            // For start operations, just mark as timeout
                            timedOutCommand.status = 'timeout';
                            timedOutCommand.error = 'Command timed out after 30 seconds';
                        }
                        
                        // Already updating in-memory executionHistory
                        renderConsoleTable();
                        console.log(`[TIMEOUT] Updated command status for ${correlationId}`);
                    } else {
                        console.log(`[TIMEOUT] Could not find command ${correlationId} to update`);
                    }
                    
                    // Clean up
                    executionListeners.delete(correlationId);
                    commandTimeouts.delete(correlationId);
                }, timeoutMs);
                
                commandTimeouts.set(correlationId, timeoutId);
                console.log(`[TIMEOUT] Set timeout for ${correlationId}, will fire in ${timeoutMs/1000} seconds`);
            } else {
                // Fallback to polling for commands without correlationId
                startPolling(commandData);
            }
            
            return commandData.id;
        }
        
        function addBulkCommand(commandType, agents, apiTime, parentCorrelationId) {
            const parentId = addConsoleCommand(commandType, '-', apiTime, parentCorrelationId, false);
            
            // Add child commands for each agent
            agents.forEach(agent => {
                const childCommand = commandType.replace('-all', '');
                // Child commands don't have their own correlationId in bulk operations
                addConsoleCommand(agent.name, childCommand, 'pending', null, true, parentId);
            });
            
            return parentId;
        }
        
        function getExpectedState(command) {
            if (command.includes('start')) return 'online';
            if (command.includes('stop')) return 'offline';
            return 'unknown';
        }
        
        function getStoredCommands() {
            // Return in-memory execution history (Chrome DevTools style)
            return executionHistory;
        }
        
        function updateStoredCommands(commands) {
            // Update the in-memory execution history
            executionHistory = commands;
        }
        
        function sortCommandsForDisplay(commands) {
            // Create a map to group commands by parent
            const commandGroups = new Map();
            const rootCommands = [];
            
            // First pass: organize commands
            commands.forEach(cmd => {
                if (cmd.isChild && cmd.parentId) {
                    if (!commandGroups.has(cmd.parentId)) {
                        commandGroups.set(cmd.parentId, []);
                    }
                    commandGroups.get(cmd.parentId).push(cmd);
                } else {
                    rootCommands.push(cmd);
                }
            });
            
            // Second pass: build sorted array with parents above children
            const result = [];
            
            rootCommands.forEach(rootCmd => {
                // Add parent command
                result.push(rootCmd);
                
                // Add its children immediately after (in their original order)
                const children = commandGroups.get(rootCmd.correlationId);
                if (children) {
                    result.push(...children);
                }
            });
            
            return result;
        }
        
        function renderConsoleTable() {
            const commands = getStoredCommands();
            const tbody = document.getElementById('console-table-body');
            
            // Sort commands so parent commands appear above their children
            const sortedCommands = sortCommandsForDisplay(commands);
            
            tbody.innerHTML = sortedCommands.map(cmd => {
                const rowClass = cmd.isChild ? 'console-row-child' : '';
                const agentCell = cmd.isChild ? `<td class="${rowClass}">${cmd.agent}</td>` : `<td>${cmd.agent}</td>`;
                
                // Format completion datetime (callback time)
                let completionDisplay = '-';
                if (cmd.callbackTime) {
                    const callbackDate = new Date(cmd.callbackTime);
                    const duration = cmd.callbackTime - cmd.startTime;
                    completionDisplay = `${callbackDate.toLocaleTimeString('en-US', { hour12: false })} (${(duration/1000).toFixed(1)}s)`;
                }
                
                // Determine status display
                let statusDisplay = '';
                let statusClass = '';
                
                if (cmd.status === 'pending') {
                    // Show elapsed time for pending commands
                    const elapsed = Date.now() - cmd.startTime;
                    const elapsedSecs = Math.floor(elapsed / 1000);
                    
                    // For parent commands, show pending children count
                    if (!cmd.isChild && cmd.correlationId && (cmd.correlationId.startsWith('start-all_') || 
                        cmd.correlationId.startsWith('stop-all_') || cmd.correlationId.startsWith('parent_'))) {
                        // Count pending children
                        const pendingChildren = commands.filter(c => 
                            c.isChild && c.parentId === cmd.correlationId && c.status === 'pending'
                        ).length;
                        if (pendingChildren > 0) {
                            statusDisplay = `pending - ${pendingChildren} children waiting (${elapsedSecs}s)`;
                        } else {
                            statusDisplay = `pending (${elapsedSecs}s)`;
                        }
                    } else {
                        statusDisplay = `pending (${elapsedSecs}s)`;
                    }
                    statusClass = 'status-polling';
                } else if (cmd.status === 'success') {
                    statusDisplay = 'success';
                    statusClass = 'status-completed';
                } else if (cmd.status === 'failed') {
                    statusDisplay = cmd.error || 'failed';
                    statusClass = 'status-failed';
                } else if (cmd.status === 'timeout') {
                    const timeoutSecs = cmd.command.includes('manager') ? 120 : 60;
                    statusDisplay = `timeout (${timeoutSecs}s)`;
                    statusClass = 'status-timeout';
                } else if (cmd.status === 'timeoutSuccess') {
                    statusDisplay = 'timeout (partial)';
                    statusClass = 'status-timeout-success';
                } else if (cmd.status === 'manualTermination') {
                    statusDisplay = 'terminated';
                    statusClass = 'status-manual-termination';
                } else if (cmd.status === 'partialSuccess') {
                    statusDisplay = 'partial success';
                    statusClass = 'status-partial-success';
                }
                
                // Log column - always show View link if correlationId exists
                const logCell = cmd.correlationId ? 
                    `<td><a href="#" onclick="window.performControlAction('viewLogs', {correlationId: '${cmd.correlationId}', agent: '${cmd.agent}'}); return false;" style="color: var(--accent-primary); text-decoration: none;">View</a></td>` : 
                    '<td>-</td>';
                
                return `
                    <tr data-command-id="${cmd.id}" data-correlation-id="${cmd.correlationId || ''}">
                        <td>${cmd.time}</td>
                        ${agentCell}
                        <td>${cmd.command}</td>
                        <td>${completionDisplay}</td>
                        <td class="${statusClass}">${statusDisplay}</td>
                        ${logCell}
                    </tr>
                `;
            }).join('');
        }
        
        function startPolling(commandData) {
            if (commandData.completed) return;
            
            const pollerId = setInterval(async () => {
                try {
                    const response = await getAgents();
                    if (!response || !response.agents || !Array.isArray(response.agents)) {
                        console.warn('Invalid agents response in polling');
                        return;
                    }
                    
                    const agent = response.agents.find(a => a && a.name === commandData.agent);
                    
                    if (agent && hasReachedExpectedState(agent, commandData)) {
                        // Command completed
                        const completionTime = Date.now() - commandData.startTime;
                        updateCommandCompletion(commandData.id, `${(completionTime/1000).toFixed(1)}s`);
                        clearInterval(pollerId);
                        activePollers.delete(commandData.id);
                        
                        // Check if parent command should be updated
                        if (commandData.parentId) {
                            checkParentCompletion(commandData.parentId);
                        }
                    }
                } catch (error) {
                    console.error('Polling error:', error);
                    // Don't stop polling on error, just log it
                }
            }, 10000); // Poll every 10 seconds
            
            activePollers.set(commandData.id, pollerId);
        }
        
        function hasReachedExpectedState(agent, commandData) {
            if (commandData.command.includes('manager')) {
                // Check manager status
                return agent.managerVersion && agent.managerVersion !== 'unknown';
            } else {
                // Check agent status
                return commandData.expectedState === 'online' ? agent.isOnline : !agent.isOnline;
            }
        }
        
        function updateCommandCompletion(commandId, uiTime) {
            const commands = getStoredCommands();
            const command = commands.find(c => c.id === commandId);
            if (command) {
                command.uiTime = uiTime;
                command.completed = true;
                // Already updating in-memory executionHistory
                renderConsoleTable();
            }
        }
        
        function checkParentCompletion(parentId) {
            const commands = getStoredCommands();
            const childCommands = commands.filter(c => c.parentId === parentId);
            const allCompleted = childCommands.every(c => c.completed);
            
            if (allCompleted) {
                const maxTime = Math.max(...childCommands.map(c => parseFloat(c.uiTime) || 0));
                updateCommandCompletion(parentId, `${maxTime.toFixed(1)}s`);
            }
        }
        
        function restorePolling() {
            try {
                const commands = getStoredCommands();
                console.log('Restoring polling for', commands.length, 'commands');
                commands.forEach(cmd => {
                    if (!cmd.completed && cmd.uiTime === 'polling') {
                        console.log('Resuming polling for command:', cmd);
                        startPolling(cmd);
                    }
                });
            } catch (error) {
                console.error('Error in restorePolling:', error);
            }
        }
        
        function saveConsoleContent(content) {
            // Legacy function for backward compatibility
        }
        
        function getConsoleContent() {
            return '';
        }
        
        function clearConsoleContent() {
            const activeTab = window.activeConsoleTab || 'chat';
            const tabName = activeTab === 'control' ? 'control' : 'chat';
            
            {
                hubGuiLog.log(null, null, 'clear-console', 
                    `User cleared ${tabName} console entries`);
                
                if (activeTab === 'control') {
                    // Clear control tab data
                    executionHistory = [];
                    activeCorrelationIds.clear();
                    activePollers.forEach(pollerId => clearInterval(pollerId));
                    activePollers.clear();
                    commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
                    commandTimeouts.clear();
                    executionListeners.clear();
                    cleanupEventSource();
                    renderConsoleTable();
                } else {
                    // Clear chat tab data
                    chatActions = [];
                    renderChatConsole();
                }
                
                console.log(`[CONSOLE] Cleared all ${tabName} console entries`);
            }
        }
        
        function renderChatConsole() {
            const chatActions = actionRouter.getChatActions();
            const tbody = document.getElementById('chat-console-table-body');
            
            if (!tbody) return;
            
            // Sort actions: parents first, then their children, newest first
            const sortedActions = [...chatActions].sort((a, b) => {
                // If one is parent of the other, parent comes first
                if (a.correlationId === b.parentId) return -1;
                if (b.correlationId === a.parentId) return 1;
                
                // Otherwise sort by time, newest first
                return b.startTime - a.startTime;
            });
            
            tbody.innerHTML = sortedActions.map(action => {
                const startDate = new Date(action.startTime);
                const timeStr = startDate.toLocaleTimeString('en-US', { hour12: false });
                
                // Add child indicator if this is a child action
                const isChild = action.isChild || action.parentId;
                const actionDisplay = isChild ? `↳ ${action.action}` : action.action;
                
                // Status display with colors
                let statusDisplay = '';
                let statusClass = '';
                
                switch (action.status) {
                    case 'pending':
                        const elapsed = Date.now() - action.startTime;
                        statusDisplay = `Pending (${Math.floor(elapsed / 1000)}s)`;
                        statusClass = 'status-polling';
                        break;
                    case 'success':
                        // For startTask, clarify that the task was queued, not completed
                        if (action.action === 'startTask') {
                            statusDisplay = 'Queued';
                        } else {
                            statusDisplay = 'Success';
                        }
                        statusClass = 'status-completed';
                        break;
                    case 'error':
                        statusDisplay = 'Error';
                        statusClass = 'status-failed';
                        break;
                    case 'debug':
                        statusDisplay = 'Debug';
                        statusClass = 'status-debug';
                        break;
                    case 'info':
                        statusDisplay = 'Info';
                        statusClass = 'status-info';
                        break;
                    default:
                        statusDisplay = action.status || 'Unknown';
                        statusClass = '';
                }
                
                // Format details based on action type
                let detailsText = '';
                if (action.action === 'markdownRender' && action.details) {
                    detailsText = `Raw: ${action.details.rawLength} → Rendered: ${action.details.renderedLength}`;
                    if (action.details.hasStrayTags) {
                        detailsText += ' <span style="color: var(--error);">⚠️ Stray tags</span>';
                    }
                    if (action.details.truncatedTable) {
                        detailsText += ' <span style="color: var(--warning);">📋 Truncated</span>';
                    }
                } else if (action.action === 'markdown-cleanup' && action.details) {
                    detailsText = `Found ${action.details.strayTagCount} stray tags`;
                } else {
                    // Show key action info based on action type
                    const details = [];
                    
                    // Special handling for startTask action
                    if (action.action === 'startTask' && action.params.initialPrompt) {
                        const prompt = action.params.initialPrompt;
                        if (prompt.length > 60) {
                            details.push(`"${prompt.substring(0, 57)}..."`);
                        } else {
                            details.push(`"${prompt}"`);
                        }
                    } else {
                        // Show correlation IDs for other actions
                        if (action.guid) details.push(`guid: ${action.guid.substring(0, 8)}...`);
                        if (action.correlationId) details.push(`correlationId: ${action.correlationId.substring(0, 8)}...`);
                        if (action.isRoot) details.push('ROOT');
                        if (action.parentId) details.push(`parent: ${action.parentId.substring(0, 8)}...`);
                        
                        // Add params if they exist and aren't empty (but skip initialPrompt and tabTitle)
                        if (action.params && Object.keys(action.params).length > 0) {
                            const filteredParams = Object.keys(action.params)
                                .filter(k => k !== 'initialPrompt' && k !== 'tabTitle')
                                .map(k => `${k}: ${action.params[k]}`);
                            if (filteredParams.length > 0) {
                                const paramStr = filteredParams.join(', ');
                                if (paramStr.length > 30) {
                                    details.push(paramStr.substring(0, 27) + '...');
                                } else if (paramStr) {
                                    details.push(paramStr);
                                }
                            }
                        }
                    }
                    
                    detailsText = details.join(', ');
                }
                
                // View log link
                const logCell = `<td><a href="#" onclick="window.performControlAction('viewChatActionLog', {guid: '${action.guid}'}); return false;" style="color: var(--accent-primary); text-decoration: none;">View</a></td>`;
                
                return `
                    <tr data-guid="${action.guid}" class="${isChild ? 'console-row-child' : ''}">
                        <td>${timeStr}</td>
                        <td title="${action.tabTitle || ''}">${(action.tabTitle || '').substring(0, 20)}${(action.tabTitle || '').length > 20 ? '...' : ''}</td>
                        <td>${actionDisplay}</td>
                        <td>${detailsText}</td>
                        <td class="${statusClass}">${statusDisplay}</td>
                        ${logCell}
                    </tr>
                `;
            }).join('');
        }
        
        function restorePendingTimeouts() {
            const commands = getStoredCommands();
            const now = Date.now();
            
            commands.forEach(cmd => {
                if (cmd.status === 'pending' && cmd.correlationId) {
                    const elapsed = now - cmd.timestamp;
                    const remaining = 60000 - elapsed;
                    
                    if (remaining > 0) {
                        // Command hasn't timed out yet, set a new timeout for remaining time
                        const timeoutId = setTimeout(() => {
                            console.log(`[TIMEOUT] Restored command ${cmd.correlationId} timed out`);
                            
                            // Update command status to timeout
                            const currentCommands = getStoredCommands();
                            const timedOutCommand = currentCommands.find(c => c.correlationId === cmd.correlationId);
                            if (timedOutCommand && timedOutCommand.status === 'pending') {
                                timedOutCommand.status = 'timeout';
                                timedOutCommand.error = 'Command timed out after 60 seconds';
                                // Already updating in-memory executionHistory
                                renderConsoleTable();
                            }
                            
                            commandTimeouts.delete(cmd.correlationId);
                        }, remaining);
                        
                        commandTimeouts.set(cmd.correlationId, timeoutId);
                        console.log(`[TIMEOUT] Restored timeout for ${cmd.correlationId}, will fire in ${Math.round(remaining/1000)}s`);
                        
                        // Also restore execution listener
                        listenForExecutionUpdates(cmd.correlationId);
                    } else {
                        // Command should have already timed out
                        console.log(`[TIMEOUT] Command ${cmd.correlationId} should have timed out ${Math.round((elapsed-60000)/1000)}s ago`);
                        cmd.status = 'timeout';
                        cmd.error = 'Command timed out after 60 seconds';
                    }
                }
            });
            
            // Save any timeout updates
            // Already updating in-memory executionHistory
            renderConsoleTable();
        }
        
        // Function to instantly update agent status in UI without waiting for poll
        function updateAgentStatusInstantly(agentName, command, status, correlationId) {
            if (!agentName || agentName === 'all') return; // Skip parent commands
            
            // Log the status change
            const action = command.includes('stop') ? 'stop' : (command.includes('start') ? 'start' : command);
            const target = command.includes('manager') ? 'manager' : 'agent';
            hubGuiLog.log(agentName, correlationId, `status-change`, 
                `${target} status changed to ${status} after ${action} operation`);
            
            // Find the agent element in the DOM
            const agentsList = document.getElementById('agents-list');
            if (!agentsList) return;
            
            const agentItems = agentsList.querySelectorAll('.agent-item');
            for (const agentItem of agentItems) {
                const nameElement = agentItem.querySelector('.agent-name > div');
                if (nameElement && nameElement.textContent.includes(agentName)) {
                    const statusContainer = agentItem.querySelector('.agent-status-container');
                    if (!statusContainer) continue;
                    
                    // Determine which indicator to update based on command
                    const isManagerCommand = command.includes('manager');
                    const indicatorIndex = isManagerCommand ? 1 : 0; // M is second, A is first
                    const indicators = statusContainer.querySelectorAll('.status-indicator');
                    
                    if (indicators[indicatorIndex]) {
                        // Get previous status
                        const previousClasses = indicators[indicatorIndex].className;
                        const wasOnline = previousClasses.includes('status-online');
                        const previousStatus = wasOnline ? 'online' : 'offline';
                        
                        // For stop commands, success means offline
                        const newStatus = command.includes('stop') ? 
                            (status === 'success' || status === 'manualTermination' ? 'offline' : 'online') :
                            (status === 'success' ? 'online' : 'offline');
                        
                        // Update the indicator class
                        indicators[indicatorIndex].className = `status-indicator status-${newStatus}`;
                        
                        // Log the status change
                        const timestamp = new Date().toISOString();
                        const indicatorType = isManagerCommand ? 'M' : 'A';
                        console.log(`[${timestamp}] [STATUS-CHANGE] ${indicatorType} indicator for ${agentName} changed from ${previousStatus} to ${newStatus}${correlationId ? ` (correlationId: ${correlationId})` : ' (from polling)'}`);
                    }
                    break;
                }
            }
        }
        
        // Register tab with hub API
        async function registerTab() {
            try {
                const response = await fetch(`${API_BASE}/tabs/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tabId: TAB_ID })
                });
                
                if (response.ok) {
                    console.log(`[TAB] Tab registered with hub: ${TAB_ID}`);
                    hubGuiLog.log(null, null, 'tab-registered', `Tab registered with hub API: ${TAB_ID}`);
                }
            } catch (error) {
                console.error('[TAB] Failed to register tab:', error);
            }
        }
        
        // Client-side API routing
        function setupClientAPI() {
            // Intercept navigation to client API endpoints
            const originalPushState = history.pushState;
            const originalReplaceState = history.replaceState;
            
            function handleClientRoute() {
                const path = window.location.pathname;
                const params = new URLSearchParams(window.location.search);
                
                // Check if this is a client API endpoint
                if (path.startsWith('/api/client/')) {
                    handleClientAPI(path, params);
                    return true;
                }
                return false;
            }
            
            // Override history methods
            history.pushState = function() {
                originalPushState.apply(history, arguments);
                handleClientRoute();
            };
            
            history.replaceState = function() {
                originalReplaceState.apply(history, arguments);
                handleClientRoute();
            };
            
            // Handle browser navigation
            window.addEventListener('popstate', handleClientRoute);
            
            // Check current URL on load
            handleClientRoute();
        }
        
        // Handle client-side API requests
        function handleClientAPI(path, params) {
            const format = params.get('format') || 'json';
            let response = null;
            
            switch (path) {
                case '/api/client/logs':
                    response = hubGuiLog.getLogs({
                        worker: params.get('worker'),
                        correlationId: params.get('correlationId'),
                        action: params.get('action'),
                        from: params.get('from'),
                        to: params.get('to'),
                        last: params.get('last') ? parseInt(params.get('last')) : null
                    });
                    break;
                    
                case '/api/client/logs/interleaved':
                    // Get interleaved logs for a specific correlationId
                    const correlationId = params.get('correlationId');
                    if (!correlationId) {
                        response = { error: 'correlationId parameter required' };
                        break;
                    }
                    
                    // Fetch execution logs from hub and interleave with UI logs
                    fetch(`${API_BASE}/executions/${correlationId}`)
                        .then(resp => resp.json())
                        .then(execution => {
                            const uiEvents = hubGuiLog.getLogs({ correlationId: correlationId });
                            
                            // Create the same interleaved view as the UI
                            const interleavedLogs = [];
                            const startTime = execution.startTime;
                            
                            // Add UI events
                            uiEvents.forEach(uiEvent => {
                                const eventTime = new Date(uiEvent.datetime).getTime();
                                interleavedLogs.push({
                                    timestamp: uiEvent.datetime,
                                    elapsed: eventTime - startTime,
                                    type: 'UI_EVENT',
                                    source: 'ui',
                                    message: `${uiEvent.action}: ${uiEvent.description}`,
                                    color: '#bb86fc'
                                });
                            });
                            
                            // Add execution logs
                            if (execution.logs) {
                                execution.logs.forEach(log => {
                                    const timestampMatch = log.match(/\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\]/);
                                    if (timestampMatch) {
                                        const logTime = new Date(timestampMatch[1]).getTime();
                                        const message = log.substring(log.indexOf(']') + 1).trim();
                                        interleavedLogs.push({
                                            timestamp: timestampMatch[1],
                                            elapsed: logTime - startTime,
                                            type: 'EXECUTION',
                                            source: 'backend',
                                            message: message,
                                            raw: log
                                        });
                                    }
                                });
                            }
                            
                            // Sort by timestamp
                            interleavedLogs.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                            
                            response = {
                                correlationId: correlationId,
                                command: execution.command,
                                agent: execution.agent,
                                status: execution.status,
                                startTime: execution.startTime,
                                endTime: execution.endTime,
                                logs: interleavedLogs
                            };
                            
                            // Display the response
                            displayClientResponse(response, format);
                        })
                        .catch(error => {
                            response = { error: error.message };
                            displayClientResponse(response, format);
                        });
                    return; // Async response
                    break;
                    
                case '/api/client/state':
                    response = {
                        tabId: TAB_ID,
                        version: HUB_VERSION,
                        timestamp: new Date().toISOString(),
                        agents: httpAgents?.getAgents() || [],
                        activeTab: activeTabId,
                        consoleVisible: typeof consoleVisible !== 'undefined' ? consoleVisible : false,
                        pendingCommands: getStoredCommands().filter(c => c.status === 'pending'),
                        sessionInfo: {
                            startTime: sessionStorage.getItem('sessionStartTime') || new Date().toISOString(),
                            logCount: hubGuiLog.getLogs().length
                        }
                    };
                    break;
                    
                case '/api/client/performance':
                    response = {
                        tabId: TAB_ID,
                        navigation: performance.getEntriesByType('navigation')[0],
                        memory: performance.memory || null,
                        timing: performance.timing
                    };
                    break;
                    
                case '/api/client/storage':
                    response = {
                        tabId: TAB_ID,
                        session: {
                            keys: Object.keys(sessionStorage),
                            size: JSON.stringify(sessionStorage).length
                        },
                        local: {
                            keys: Object.keys(localStorage),
                            size: JSON.stringify(localStorage).length
                        }
                    };
                    break;
                    
                case '/api/client/errors':
                    response = {
                        tabId: TAB_ID,
                        errors: window.collectedErrors || [],
                        message: 'Error collection not yet implemented'
                    };
                    break;
                    
                default:
                    if (path.startsWith('/api/client/action/')) {
                        handleClientAction(path.replace('/api/client/action/', ''), params);
                        return;
                    }
                    response = { error: 'Unknown client API endpoint', path };
            }
            
            // Display response
            if (format === 'html') {
                displayClientAPIResponse(response, path);
            } else {
                // JSON format - replace page content with JSON
                document.body.innerHTML = `<pre style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; padding: 20px;">${JSON.stringify(response, null, 2)}</pre>`;
            }
        }
        
        // Handle client API actions
        function handleClientAction(action, params) {
            const actions = {
                'stop-all-agents': () => stopAllAgents(),
                'stop-all-managers': () => stopAllManagers(),
                'clear-console': () => clearConsoleContent(),
                'clear-logs': () => hubGuiLog.clear(),
                'refresh-agents': () => loadAgents(),
                'simulate-click': () => {
                    const target = params.get('target');
                    const agent = params.get('agent');
                    // Implementation depends on UI structure
                    console.log(`[CLIENT-API] Simulate click: ${target} on ${agent}`);
                }
            };
            
            const actionFn = actions[action];
            if (actionFn) {
                actionFn();
                document.body.innerHTML = `<pre>Action '${action}' executed successfully</pre>`;
            } else {
                document.body.innerHTML = `<pre>Unknown action: ${action}</pre>`;
            }
        }
        
        // Display client API response in HTML format
        function displayClientAPIResponse(data, endpoint) {
            const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Client API Response - ${endpoint}</title>
                    <style>
                        body { 
                            font-family: monospace; 
                            padding: 20px; 
                            background: #1a1a1a; 
                            color: #e0e0e0;
                        }
                        pre { 
                            white-space: pre-wrap; 
                            word-wrap: break-word; 
                        }
                        .header {
                            color: #4CAF50;
                            margin-bottom: 20px;
                        }
                        .tab-info {
                            color: #2196F3;
                            margin-bottom: 10px;
                        }
                    </style>
                </head>
                <body>
                    <div class="header">Client API Response: ${endpoint}</div>
                    <div class="tab-info">Tab ID: ${TAB_ID}</div>
                    <pre>${JSON.stringify(data, null, 2)}</pre>
                </body>
                </html>
            `;
            document.documentElement.innerHTML = html;
        }
        
        // Initialize - moved here after all functions are defined
        // Set title dynamically from HUB_VERSION
        document.title = `Infrastructure AI Hub (v${HUB_VERSION})`;
        
        registerTab();
        setupClientAPI();
        
        // Clear all tabs on page load (fresh start)
        clearAllTabs();
        
        // Log hub startup
        hubGuiLog.log(null, null, 'hub-startup', 
            `Hub UI v${HUB_VERSION} loaded at ${window.location.href}`);
        
        loadHistory();
        loadAgents();
        loadHubStatus();
        initializeConsole();
        const agentRefreshInterval = setInterval(loadAgents, 5000);
        
        // Update console table every second to refresh elapsed time for pending commands
        const consoleRefreshInterval = setInterval(() => {
            const commands = getStoredCommands();
            const hasPending = commands.some(c => c.status === 'pending');
            if (hasPending) {
                renderConsoleTable();
            }
        }, 1000);
        
        // Update clock every second
        const clockInterval = setInterval(() => {
            document.getElementById('last-update').textContent = formatTime(new Date());
        }, 1000);
        // Set initial time immediately
        document.getElementById('last-update').textContent = formatTime(new Date());
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            // Clean up all intervals and timeouts
            clearInterval(agentRefreshInterval);
            clearInterval(consoleRefreshInterval);
            activePollers.forEach(pollerId => clearInterval(pollerId));
            commandTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            cleanupEventSource();
        });
        
        // Focus initial input
        document.getElementById('task-command').focus();
        
        // Hamburger menu functions (now handled by Alpine.js)
        
        // Make functions globally accessible for Alpine.js
        window.startAllAgents = startAllAgents;
        window.stopAllAgents = stopAllAgents;
        window.startAllManagers = startAllManagers;
        window.stopAllManagers = stopAllManagers;
        
        async function startAllAgents() {
            console.log('Starting all agents...');
            const agents = await getAgents();
            console.log('Found agents:', agents.agents.map(a => a.name));
            
            if (agents.agents.length === 0) {
                addMessage(activeTabId, 'No agents found to start', false);
                return;
            }
            
            // Prepare results for all agents
            const allResults = [];
            
            // Check each agent's status
            for (const agent of agents.agents) {
                if (agent.isOnline) {
                    allResults.push({
                        agent: agent.name,
                        status: 'already',
                        message: 'Already running'
                    });
                }
            }
            
            // Filter for agents that are currently offline
            const offlineAgents = agents.agents.filter(agent => !agent.isOnline);
            if (offlineAgents.length === 0) {
                showSummaryModal('Start All Agents - Complete', allResults);
                return;
            }
            
            const startTime = Date.now();
            const parentCorrelationId = `start-all_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            try {
                // Add parent command to console
                const commandId = addConsoleCommand('', 'start-all', 'pending', parentCorrelationId, false);
                
                // Create child correlation IDs for each agent
                const childOperations = [];
                
                for (const agent of offlineAgents) {
                    // Check if manager is online
                    const managerVersion = agent.managerVersion || agent.manager?.version;
                    const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== '';
                    
                    if (!managerOnline) {
                        console.log(`Skipping ${agent.name} - manager not online`);
                        allResults.push({
                            agent: agent.name,
                            status: 'failed',
                            message: 'Manager must be running to control agent'
                        });
                        continue;
                    }
                    
                    const childCorrelationId = `start_${agent.name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    childOperations.push({
                        agent: agent.name,
                        correlationId: childCorrelationId
                    });
                    
                    // Add child command to console
                    addConsoleCommand(agent.name, 'start', 'pending', childCorrelationId, true, parentCorrelationId);
                    
                    // Listen for execution updates for this child
                    listenForExecutionUpdates(childCorrelationId);
                }
                
                if (childOperations.length === 0) {
                    updateCommandStatus(parentCorrelationId, { status: 'failed', error: 'No agents available to start (managers not running)' });
                    showSummaryModal('Start All Agents - Complete', allResults);
                    return;
                }
                
                // Use new multi-agent endpoint
                try {
                    // Log the operation
                    hubGuiLog.log('all', parentCorrelationId, 'start-all-agents', 
                        `Starting all agents: ${childOperations.map(op => op.agent).join(', ')}`);
                    
                    const response = await fetch(`${API_BASE}/agents/multi/start`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            agents: childOperations.map(op => op.agent),
                            parentCorrelationId,
                            tabId: TAB_ID 
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.text();
                        console.error('Multi-agent start failed:', error);
                        updateCommandStatus(parentCorrelationId, { status: 'failed', error });
                        return;
                    }
                    
                    const result = await response.json();
                    console.log('Multi-agent start initiated:', result);
                    
                    // The parent will be automatically updated when all children complete
                    // Listen for parent execution updates
                    listenForExecutionUpdates(parentCorrelationId);
                } catch (error) {
                    console.error('Multi-agent start error:', error);
                    updateCommandStatus(parentCorrelationId, { status: 'failed', error: error.message });
                    showSummaryModal('Start All Agents - Failed', [{
                        agent: 'multi-agent',
                        status: 'failed',
                        message: error.message
                    }]);
                }
                
            } catch (error) {
                updateCommandStatus(parentCorrelationId, { status: 'failed', error: error.message });
                addMessage(activeTabId, `Error starting agents: ${error.message}`, false);
            }
            
            setTimeout(loadAgents, 3000);
        }
        
        async function stopAllAgents() {
            console.log('Stopping all agents...');
            const agents = await getAgents();
            
            if (agents.agents.length === 0) {
                addMessage(activeTabId, 'No agents found to stop', false);
                return;
            }
            
            // Prepare results for all agents
            const allResults = [];
            
            // Check each agent's status
            for (const agent of agents.agents) {
                if (!agent.isOnline) {
                    allResults.push({
                        agent: agent.name,
                        status: 'already',
                        message: 'Already stopped'
                    });
                }
            }
            
            // Filter for agents that are currently online
            const onlineAgents = agents.agents.filter(agent => agent.isOnline);
            if (onlineAgents.length === 0) {
                showSummaryModal('Stop All Agents - Complete', allResults);
                return;
            }
            
            const startTime = Date.now();
            const parentCorrelationId = `stop-all_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            try {
                // Add parent command to console
                const commandId = addConsoleCommand('', 'stop-all', 'pending', parentCorrelationId, false);
                
                // Create child correlation IDs for each agent
                const childOperations = [];
                
                for (const agent of onlineAgents) {
                    // Check if manager is online
                    const managerVersion = agent.managerVersion || agent.manager?.version;
                    // Manager is online if it has any version that's not explicitly 'unknown' or 'offline'
                    const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== 'offline';
                    
                    if (!managerOnline) {
                        console.log(`Skipping ${agent.name} - manager not online`);
                        allResults.push({
                            agent: agent.name,
                            status: 'failed',
                            message: 'Manager must be running to control agent'
                        });
                        continue;
                    }
                    
                    const childCorrelationId = `stop_${agent.name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    childOperations.push({
                        agent: agent.name,
                        correlationId: childCorrelationId
                    });
                    
                    // Add child command to console
                    addConsoleCommand(agent.name, 'stop', 'pending', childCorrelationId, true, parentCorrelationId);
                    
                    // Listen for execution updates for this child
                    listenForExecutionUpdates(childCorrelationId);
                }
                
                if (childOperations.length === 0) {
                    updateCommandStatus(parentCorrelationId, { status: 'failed', error: 'No agents available to stop (managers not running)' });
                    showSummaryModal('Stop All Agents - Complete', allResults);
                    return;
                }
                
                // Use new multi-agent endpoint
                try {
                    // Log the operation
                    hubGuiLog.log('all', parentCorrelationId, 'stop-all-agents', 
                        `Stopping all agents: ${childOperations.map(op => op.agent).join(', ')}`);
                    
                    const response = await fetch(`${API_BASE}/agents/multi/stop`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            agents: childOperations.map(op => op.agent),
                            parentCorrelationId,
                            tabId: TAB_ID 
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.text();
                        console.error('Multi-agent stop failed:', error);
                        updateCommandStatus(parentCorrelationId, { status: 'failed', error });
                        return;
                    }
                    
                    const result = await response.json();
                    console.log('Multi-agent stop initiated:', result);
                    
                    // The parent will be automatically updated when all children complete
                    // Listen for parent execution updates
                    listenForExecutionUpdates(parentCorrelationId);
                } catch (error) {
                    console.error('Multi-agent stop error:', error);
                    updateCommandStatus(parentCorrelationId, { status: 'failed', error: error.message });
                    showSummaryModal('Stop All Agents - Failed', [{
                        agent: 'multi-agent',
                        status: 'failed',
                        message: error.message
                    }]);
                }
                
            } catch (error) {
                updateCommandStatus(parentCorrelationId, { status: 'failed', error: error.message });
                addMessage(activeTabId, `Error stopping agents: ${error.message}`, false);
            }
            
            setTimeout(loadAgents, 3000);
        }
        
        async function startAllManagers() {
            const operationStartTime = Date.now();
            console.log(`[${new Date().toISOString()}] Starting startAllManagers operation`);
            const agents = await getAgents();
            
            if (agents.agents.length === 0) {
                addMessage(activeTabId, 'No agents found to start managers for', false);
                return;
            }
            
            // Prepare results for all managers
            const allResults = [];
            
            // Check each agent's manager status
            for (const agent of agents.agents) {
                const managerVersion = agent.managerVersion || agent.manager?.version;
                const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== '';
                
                if (managerOnline) {
                    allResults.push({
                        agent: agent.name,
                        status: 'already',
                        message: 'Manager already running'
                    });
                }
            }
            
            // Filter out agents that already have managers running
            const agentsNeedingManagerStart = agents.agents.filter(agent => {
                const managerVersion = agent.managerVersion || agent.manager?.version;
                const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== '';
                return !managerOnline;
            });
            
            // Create parent command for tracking
            const parentCorrelationId = 'parent_' + Date.now();
            // Add parent command to console
            addConsoleCommand('all', 'start-all-managers', 'pending', parentCorrelationId, false);
            
            if (agentsNeedingManagerStart.length === 0) {
                // Mark parent as completed immediately
                updateCommandStatus(parentCorrelationId, { 
                    status: 'completed', 
                    result: 'All managers already running' 
                });
                const totalDuration = Date.now() - operationStartTime;
                showSummaryModal('Start All Managers - Complete', allResults, totalDuration);
                return;
            }
            
            try {
                // Track pending operations for callback duration calculation
                const pendingOperations = new Map();
                
                // Start managers on all agents that need it
                const startPromises = agentsNeedingManagerStart.map(async (agent) => {
                    const dispatchTime = Date.now();
                    const correlationId = 'cmd_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    // Store dispatch time for callback duration calculation
                    pendingOperations.set(correlationId, {
                        agent: agent.name,
                        dispatchTime: dispatchTime
                    });
                    
                    try {
                        console.log(`[${new Date().toISOString()}] Sending start-manager command to ${agent.name} (correlationId: ${correlationId})`);
                        
                        // Add child command to console
                        addConsoleCommand(agent.name, 'startManager', 'pending', correlationId, true, parentCorrelationId);
                        listenForExecutionUpdates(correlationId);
                        
                        const response = await fetch(`${API_BASE}/managers/${agent.name}/start`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                correlationId: correlationId
                            })
                        });
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`HTTP ${response.status}: ${errorText}`);
                        }
                        
                        const result = await response.json();
                        
                        console.log(`[${new Date().toISOString()}] Manager start command sent to ${agent.name} (correlationId: ${correlationId})`);
                        
                        // Don't add to allResults here - wait for callback
                        // The status will be updated via correlation tracker
                        return { agent: agent.name, correlationId, dispatched: true };
                    } catch (error) {
                        console.error(`Error starting manager for ${agent.name}:`, error);
                        
                        // Update command status directly for immediate failures
                        updateCommandStatus(correlationId, { status: 'failed', error: error.message });
                        
                        return { agent: agent.name, success: false, error: error.message, correlationId };
                    }
                });
                
                const results = await Promise.all(startPromises);
                console.log('Manager start results:', results);
                
                // Wait for all manager operations to complete via correlation tracking
                const childCorrelationIds = agentsNeedingManagerStart.map(agent => {
                    return results.find(r => r.agent === agent.name)?.correlationId;
                }).filter(id => id);
                
                console.log('Child correlation IDs to wait for:', childCorrelationIds);
                
                if (childCorrelationIds.length > 0) {
                    await waitForOperationsToComplete(childCorrelationIds);
                }
                
                // Build final results from completed commands
                const commands = getStoredCommands();
                const finalResults = [];
                
                // Add results from child commands that completed
                for (const childId of childCorrelationIds) {
                    const command = commands.find(c => c.correlationId === childId);
                    if (command) {
                        const callbackDuration = command.callbackTime ? 
                            command.callbackTime - command.timestamp : null;
                        
                        finalResults.push({
                            agent: command.agent,
                            status: command.status === 'completed' ? 'success' : 
                                   command.status === 'timeout' ? 'timeout' : 'failed',
                            message: command.status === 'completed' ? 'Manager started' : 
                                    command.status === 'timeout' ? 'Operation timed out' :
                                    (command.error || 'Failed to start manager'),
                            callbackDuration: callbackDuration
                        });
                    }
                }
                
                // Add already running managers
                allResults.forEach(result => {
                    if (result.status === 'already') {
                        finalResults.push(result);
                    }
                });
                
                // Update parent command status AFTER children complete
                const successful = finalResults.filter(r => r.status === 'success').length;
                const failed = finalResults.filter(r => r.status === 'failed' || r.status === 'timeout').length;
                
                // Update parent status
                if (failed === 0 && successful > 0) {
                    updateCommandStatus(parentCorrelationId, { status: 'completed', result: `${successful} managers started` });
                } else if (successful === 0) {
                    updateCommandStatus(parentCorrelationId, { status: 'failed', error: `All operations failed` });
                } else {
                    updateCommandStatus(parentCorrelationId, { status: 'partialSuccess', result: `${successful} of ${finalResults.length} managers started` });
                }
                
                // Refresh agent status to get updated manager versions
                await loadAgents();
                
                // Calculate total duration from operation start to dialog display
                const totalDuration = Date.now() - operationStartTime;
                console.log(`[${new Date().toISOString()}] Operation completed in ${totalDuration}ms`);
                
                // Show summary dialog with timing
                showSummaryModal('Start All Managers - Complete', finalResults, totalDuration);
                
            } catch (error) {
                updateCommandStatus(parentCorrelationId, { status: 'failed', error: error.message });
                addMessage(activeTabId, `Error starting managers: ${error.message}`, false);
                // Show error dialog immediately on failure
                const totalDuration = Date.now() - operationStartTime;
                showSummaryModal('Start All Managers - Failed', allResults, totalDuration);
            }
        }
        
        async function stopAllManagers() {
            const operationStartTime = Date.now();
            console.log(`[${new Date().toISOString()}] Starting stopAllManagers operation`);
            const agents = await getAgents();
            
            if (agents.agents.length === 0) {
                addMessage(activeTabId, 'No agents found to stop managers for', false);
                return;
            }
            
            // Prepare results for all managers
            const allResults = [];
            
            // Check each agent's manager status
            for (const agent of agents.agents) {
                const managerVersion = agent.managerVersion || agent.manager?.version;
                const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== '';
                
                if (!managerOnline) {
                    allResults.push({
                        agent: agent.name,
                        status: 'already',
                        message: 'Manager already stopped'
                    });
                }
            }
            
            // Filter out agents that already have managers stopped
            const agentsNeedingManagerStop = agents.agents.filter(agent => {
                const managerVersion = agent.managerVersion || agent.manager?.version;
                const managerOnline = managerVersion && managerVersion !== 'unknown' && managerVersion !== '';
                return managerOnline;
            });
            
            // Create parent command for tracking
            const parentCorrelationId = 'parent_' + Date.now();
            // Add parent command to console
            addConsoleCommand('all', 'stop-all-managers', 'pending', parentCorrelationId, false);
            
            if (agentsNeedingManagerStop.length === 0) {
                // Mark parent as completed immediately
                updateCommandStatus(parentCorrelationId, { 
                    status: 'completed', 
                    result: 'All managers already stopped' 
                });
                const totalDuration = Date.now() - operationStartTime;
                showSummaryModal('Stop All Managers - Complete', allResults, totalDuration);
                return;
            }
            
            try {
                // Track pending operations for callback duration calculation
                const pendingOperations = new Map();
                
                // Stop managers on all agents that need it
                const stopPromises = agentsNeedingManagerStop.map(async (agent) => {
                    const dispatchTime = Date.now();
                    const correlationId = 'cmd_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    
                    // Store dispatch time for callback duration calculation
                    pendingOperations.set(correlationId, {
                        agent: agent.name,
                        dispatchTime: dispatchTime
                    });
                    
                    try {
                        console.log(`[${new Date().toISOString()}] Sending stop-manager command to ${agent.name} (correlationId: ${correlationId})`);
                        
                        // Add child command to console
                        addConsoleCommand(agent.name, 'stopManager', 'pending', correlationId, true, parentCorrelationId);
                        listenForExecutionUpdates(correlationId);
                        
                        const response = await fetch(`${API_BASE}/managers/${agent.name}/stop`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                correlationId: correlationId
                            })
                        });
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`HTTP ${response.status}: ${errorText}`);
                        }
                        
                        const result = await response.json();
                        
                        console.log(`[${new Date().toISOString()}] Manager stop command sent to ${agent.name} (correlationId: ${correlationId})`);
                        
                        // Don't add to allResults here - wait for callback
                        // The status will be updated via correlation tracker
                        return { agent: agent.name, correlationId, dispatched: true };
                    } catch (error) {
                        console.error(`Error starting manager for ${agent.name}:`, error);
                        
                        // Update command status directly for immediate failures
                        updateCommandStatus(correlationId, { status: 'failed', error: error.message });
                        
                        return { agent: agent.name, success: false, error: error.message, correlationId };
                    }
                });
                
                const results = await Promise.all(stopPromises);
                console.log('Manager stop results:', results);
                
                // Wait for all manager operations to complete via correlation tracking
                const childCorrelationIds = agentsNeedingManagerStop.map(agent => {
                    return results.find(r => r.agent === agent.name)?.correlationId;
                }).filter(id => id);
                
                console.log('Child correlation IDs to wait for:', childCorrelationIds);
                
                if (childCorrelationIds.length > 0) {
                    await waitForOperationsToComplete(childCorrelationIds);
                }
                
                // Build final results from completed commands
                const commands = getStoredCommands();
                const finalResults = [];
                
                // Add results from child commands that completed
                for (const childId of childCorrelationIds) {
                    const command = commands.find(c => c.correlationId === childId);
                    if (command) {
                        const callbackDuration = command.callbackTime ? 
                            command.callbackTime - command.timestamp : null;
                        
                        finalResults.push({
                            agent: command.agent,
                            status: command.status === 'completed' ? 'success' : 
                                   command.status === 'manualTermination' ? 'manualTermination' :
                                   command.status === 'timeout' ? 'timeout' : 'failed',
                            message: command.status === 'completed' ? 'Manager stopped' : 
                                    command.status === 'manualTermination' ? 'Force killed' :
                                    command.status === 'timeout' ? 'Operation timed out' :
                                    (command.error || 'Failed to stop manager'),
                            callbackDuration: callbackDuration
                        });
                    }
                }
                
                // Add already stopped managers
                allResults.forEach(result => {
                    if (result.status === 'already') {
                        finalResults.push(result);
                    }
                });
                
                // Update parent command status AFTER children complete
                const successful = finalResults.filter(r => r.status === 'success').length;
                const manuallyTerminated = finalResults.filter(r => r.status === 'manualTermination').length;
                const failed = finalResults.filter(r => r.status === 'failed' || r.status === 'timeout').length;
                
                // Update parent status
                if (failed === 0 && manuallyTerminated === 0 && successful > 0) {
                    updateCommandStatus(parentCorrelationId, { status: 'completed', result: `${successful} managers stopped` });
                } else if (successful === 0 && manuallyTerminated === 0) {
                    updateCommandStatus(parentCorrelationId, { status: 'failed', error: `All operations failed` });
                } else {
                    const total = successful + manuallyTerminated;
                    updateCommandStatus(parentCorrelationId, { status: 'partialSuccess', result: `${total} of ${finalResults.length} managers stopped` });
                }
                
                // Refresh agent status to get updated manager versions
                await loadAgents();
                
                // Calculate total duration from operation start to dialog display
                const totalDuration = Date.now() - operationStartTime;
                console.log(`[${new Date().toISOString()}] Operation completed in ${totalDuration}ms`);
                
                // Show summary dialog with timing
                showSummaryModal('Stop All Managers - Complete', finalResults, totalDuration);
                
            } catch (error) {
                updateCommandStatus(parentCorrelationId, { status: 'failed', error: error.message });
                addMessage(activeTabId, `Error stopping managers: ${error.message}`, false);
                // Show error dialog immediately on failure
                const totalDuration = Date.now() - operationStartTime;
                showSummaryModal('Stop All Managers - Failed', allResults, totalDuration);
            }
        }
        
        async function getAgents() {
            const response = await fetch(`${API_BASE}/agents`);
            return await response.json();
        }
        
        // Add viewLogs function
        let viewLogsInProgress = false;
        async function viewLogs(correlationId, agentName) {
            // Prevent multiple simultaneous calls
            if (viewLogsInProgress) {
                console.log('viewLogs already in progress, ignoring duplicate call');
                return;
            }
            
            // Check if correlationId is valid
            if (!correlationId || correlationId === 'undefined') {
                console.error('Invalid correlationId:', correlationId);
                alert('Error: No correlationId available for this command');
                return;
            }
            
            viewLogsInProgress = true;
            console.log(`Viewing logs for correlationId: ${correlationId} on agent: ${agentName}`);
            
            try {
                // First, get the hub's correlation tracker logs
                const hubResponse = await fetch(`${API_BASE}/executions/${correlationId}`);
                if (!hubResponse.ok) {
                    if (hubResponse.status === 404) {
                        throw new Error(`No logs found for correlationId: ${correlationId}`);
                    }
                    throw new Error(`Failed to fetch logs: ${hubResponse.status} ${hubResponse.statusText}`);
                }
                
                const execution = await hubResponse.json();
                
                // Also get UI events from hubGuiLog for this correlationId
                const uiEvents = hubGuiLog.getLogs({ correlationId: correlationId });
                
                // Create modal to show logs
                const modal = document.createElement('div');
                modal.className = 'modal log-viewer-modal';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 90%; max-height: 80vh;">
                        <div class="modal-header">
                            <h2>Logs for ${execution.agent.toUpperCase()} ${execution.command.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}</h2>
                            <span class="close-button" onclick="window.performControlAction('closeModal', {element: this})">&times;</span>
                        </div>
                        <div class="modal-body">
                            <div class="command-info-section">
                                <h3 style="margin-top: 0;">Command: ${execution.command}</h3>
                                <div class="command-info">
                                    <div class="command-info-row">
                                        <span><strong>Status:</strong> ${execution.status}</span>
                                    </div>
                                    <div class="command-info-row">
                                        <span><strong>Started:</strong> ${new Date(execution.startTime).toLocaleTimeString()}</span>
                                        ${execution.endTime ? `<span><strong>Completed:</strong> ${new Date(execution.endTime).toLocaleTimeString()}</span>` : ''}
                                    </div>
                                    <div class="command-info-row">
                                        <span><strong>Total duration:</strong> ${execution.endTime ? `${execution.endTime - execution.startTime}ms` : 'In progress...'}</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="sections-container">
                                <div class="timeline-section">
                                    <h3>Execution Timeline:</h3>
                                    <div class="timeline-content">
                                        ${renderExecutionTimeline(execution, uiEvents)}
                                    </div>
                                </div>
                                
                                <div class="logs-section">
                                    <h3>Execution Logs:</h3>
                                    <div class="logs-content">
                                        ${formatHubLogs(execution.logs, uiEvents)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
                modal.style.display = 'block';
            } catch (error) {
                console.error('Failed to fetch logs:', error);
                alert('Failed to fetch logs: ' + error.message);
            } finally {
                viewLogsInProgress = false;
            }
        }
        
        function renderExecutionTimeline(execution, uiEvents = []) {
            if (!execution.startTime) {
                return '<p style="color: #888;">No timeline data available</p>';
            }
            
            // Extract and group events from logs
            const events = [];
            const startTime = execution.startTime;
            
            // Add UI events to the timeline
            uiEvents.forEach(uiEvent => {
                const eventTime = new Date(uiEvent.datetime).getTime();
                const elapsed = eventTime - startTime;
                
                events.push({
                    timestamp: new Date(uiEvent.datetime),
                    time: eventTime,
                    elapsed: elapsed,
                    type: 'UI Event',
                    messages: [`${uiEvent.action}: ${uiEvent.description}`],
                    color: '#bb86fc',
                    icon: '👤',
                    source: 'ui'
                });
            });
            
            // Parse logs to extract and group events
            if (execution.logs && execution.logs.length > 0) {
                let currentEvent = null;
                
                execution.logs.forEach((log) => {
                    // Extract timestamp from log format: [2024-01-27T10:15:30.123Z] Message
                    const timestampMatch = log.match(/\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\]/);
                    if (timestampMatch) {
                        const logTime = new Date(timestampMatch[1]).getTime();
                        const elapsed = logTime - startTime;
                        
                        // Extract the message part after timestamp
                        const message = log.substring(log.indexOf(']') + 1).trim();
                        
                        // Determine event type and color
                        let eventType = '';
                        let color = '#666';
                        let icon = '•';
                        let isNewEvent = true;
                        
                        if (message.includes('[START]')) {
                            // Check if this is a stop command
                            if (message.includes('stopAgent') || message.includes('stopManager')) {
                                eventType = 'Stop';
                                color = '#e74c3c';
                                icon = '■';
                            } else if (message.includes('restart-agent') || message.includes('restart-manager')) {
                                eventType = 'Restart';
                                color = '#f39c12';
                                icon = '↻';
                            } else {
                                eventType = 'Start';
                                color = '#4a90e2';
                                icon = '▶';
                            }
                        } else if (message.includes('[HUB]')) {
                            eventType = 'Hub';
                            color = '#7b68ee';
                            icon = '⚡';
                        } else if (message.includes('SSH command:') || message.includes('Executing SSH')) {
                            eventType = 'SSH';
                            color = '#ff6b6b';
                            icon = '🔌';
                        } else if (message.includes('[NOTIFICATION]')) {
                            eventType = 'Notify';
                            color = '#4ecdc4';
                            icon = '📢';
                        } else if (message.includes('[POLLING]')) {
                            eventType = 'Poll';
                            color = '#f39c12';
                            icon = '🔄';
                        } else if (message.includes('[CALLBACK]')) {
                            eventType = 'Callback';
                            color = '#27ae60';
                            icon = '✓';
                        } else if (message.includes('[TIMEOUT]')) {
                            eventType = 'Timeout';
                            color = '#e74c3c';
                            icon = '⏱';
                        } else if (message.includes('[ERROR]')) {
                            eventType = 'Error';
                            color = '#e74c3c';
                            icon = '✗';
                        } else if (currentEvent && currentEvent.type === 'SSH' && 
                                   (message.includes('Output:') || message.includes('true') || message.includes('false'))) {
                            // This is SSH output, add to previous SSH event
                            isNewEvent = false;
                        }
                        
                        // Clean the message by removing [TAG] markers
                        const cleanMessage = message.replace(/\[[^\]]+\]/g, '').trim();
                        
                        if (!isNewEvent && currentEvent) {
                            // Add to current event (SSH output case)
                            currentEvent.messages.push(cleanMessage);
                        } else if (eventType) {
                            // Start a new event
                            if (currentEvent) {
                                events.push(currentEvent);
                            }
                            currentEvent = {
                                timestamp: new Date(timestampMatch[1]),
                                time: logTime,
                                elapsed: elapsed,
                                type: eventType,
                                messages: [cleanMessage],
                                color: color,
                                icon: icon,
                                source: 'backend'
                            };
                        }
                    }
                });
                
                // Don't forget the last event
                if (currentEvent) {
                    events.push(currentEvent);
                }
            }
            
            // Sort events by elapsed time to ensure chronological order
            events.sort((a, b) => a.elapsed - b.elapsed);
            
            // Calculate total duration
            const totalDuration = (execution.endTime || Date.now()) - startTime;
            
            // Format time display
            const formatTime = (date) => {
                return date.toLocaleTimeString('en-US', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit',
                    fractionalSecondDigits: 3,
                    hour12: false
                });
            };
            
            const formatElapsed = (ms) => {
                const seconds = ms / 1000;
                if (seconds < 1) {
                    return `${ms}ms`;
                }
                return `${seconds.toFixed(1)}s`;
            };
            
            // Build tabular timeline
            let html = '<div style="background: #1a1a1a; padding: 15px; border-radius: 8px; margin: 10px 0;">';
            
            // Header
            html += `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h4 style="margin: 0; color: #fff; font-size: 14px;">Execution Timeline</h4>
                    <span style="color: #888; font-size: 12px;">Total: ${formatElapsed(totalDuration)}</span>
                </div>
            `;
            
            // Table
            html += `
                <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                    <thead>
                        <tr style="border-bottom: 1px solid #333;">
                            <th style="text-align: left; padding: 8px 4px; color: #888; font-weight: normal; width: 120px;">Time</th>
                            <th style="text-align: left; padding: 8px 4px; color: #888; font-weight: normal; width: 80px;">Elapsed</th>
                            <th style="text-align: left; padding: 8px 4px; color: #888; font-weight: normal; width: 100px;">Event</th>
                            <th style="text-align: left; padding: 8px 4px; color: #888; font-weight: normal;">Details</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Add event rows
            events.forEach((event, index) => {
                const isError = event.type === 'Error' || event.type === 'Timeout';
                const isSsh = event.type === 'SSH';
                
                // For SSH events with output, format it specially
                let detailsHtml;
                if (isSsh && event.messages.length > 1) {
                    detailsHtml = `<div>${event.messages[0]}</div>`;
                    if (event.messages.length > 1) {
                        detailsHtml += '<div style="margin-top: 4px; padding: 4px; background: #222; border-radius: 3px; font-family: monospace; font-size: 10px;">';
                        detailsHtml += event.messages.slice(1).map(msg => `<div>${msg}</div>`).join('');
                        detailsHtml += '</div>';
                    }
                } else if (event.messages.length > 1) {
                    detailsHtml = event.messages.map(msg => `<div>${msg}</div>`).join('');
                } else {
                    detailsHtml = event.messages[0] || '';
                }
                    
                html += `
                    <tr style="border-bottom: 1px solid #222; ${isError ? 'background: rgba(231, 76, 60, 0.1);' : ''}">
                        <td style="padding: 6px 4px; color: #ccc; font-family: monospace; vertical-align: top;">${formatTime(event.timestamp)}</td>
                        <td style="padding: 6px 4px; color: #666; font-family: monospace; vertical-align: top;">+${formatElapsed(event.elapsed)}</td>
                        <td style="padding: 6px 4px; vertical-align: top;">
                            <span style="color: ${event.color};">${event.icon} ${event.type}</span>
                        </td>
                        <td style="padding: 6px 4px; color: #999; font-size: 11px; vertical-align: top;">${detailsHtml}</td>
                    </tr>
                `;
            });
            
            // Add completion row if we have an end time
            if (execution.endTime) {
                const endElapsed = execution.endTime - startTime;
                html += `
                    <tr>
                        <td style="padding: 6px 4px; color: #ccc; font-family: monospace;">${formatTime(new Date(execution.endTime))}</td>
                        <td style="padding: 6px 4px; color: #666; font-family: monospace;">+${formatElapsed(endElapsed)}</td>
                        <td style="padding: 6px 4px;">
                            <span style="color: ${getStatusColor(execution.status)};">
                                ${getStatusSymbol(execution.status)}
                            </span>
                        </td>
                        <td style="padding: 6px 4px; color: #999;">${getStatusDescription(execution)}</td>
                    </tr>
                `;
            }
            
            html += `
                    </tbody>
                </table>
            `;
            
            html += '</div>';
            
            return html;
        }        
        function formatHubLogs(logs, uiEvents = []) {
            if ((!logs || logs.length === 0) && (!uiEvents || uiEvents.length === 0)) {
                return '<p style="color: #888;">No logs available</p>';
            }
            
            // Combine backend logs and UI events
            const allEvents = [];
            
            // Parse backend logs
            if (logs && logs.length > 0) {
                logs.forEach(log => {
                    const timestampMatch = log.match(/\[(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\]/);
                    if (timestampMatch) {
                        allEvents.push({
                            timestamp: new Date(timestampMatch[1]),
                            content: log,
                            type: 'backend'
                        });
                    } else {
                        // Log without timestamp
                        allEvents.push({
                            timestamp: null,
                            content: log,
                            type: 'backend'
                        });
                    }
                });
            }
            
            // Add UI events
            if (uiEvents && uiEvents.length > 0) {
                uiEvents.forEach(event => {
                    const timestamp = new Date(event.datetime);
                    const timeStr = timestamp.toISOString();
                    const content = `[${timeStr}] [UI EVENT] ${event.action}: ${event.description}`;
                    allEvents.push({
                        timestamp: timestamp,
                        content: content,
                        type: 'ui'
                    });
                });
            }
            
            // Sort all events by timestamp
            allEvents.sort((a, b) => {
                if (!a.timestamp) return 1;
                if (!b.timestamp) return -1;
                return a.timestamp - b.timestamp;
            });
            
            let html = '<div class="log-section"><pre style="background: #1e1e1e; padding: 12px; border-radius: 4px; color: #fff; overflow-x: auto;">';
            for (const event of allEvents) {
                if (event.type === 'ui') {
                    // Style UI events differently
                    html += `<span style="color: #bb86fc;">${event.content}</span>\n`;
                } else {
                    html += event.content + '\n';
                }
            }
            html += '</pre></div>';
            return html;
        }
        
        function formatLogSources(sources) {
            let html = '';
            let totalLogLines = 0;
            
            // Manager logs
            if (sources.manager && sources.manager.length > 0) {
                html += '<div class="log-section">';
                html += '<h4>Agent Manager Logs (/var/log/ai-agent-manager.log):</h4>';
                html += '<pre>' + sources.manager.join('\n') + '</pre>';
                html += '</div>';
                totalLogLines += sources.manager.length;
            }
            
            // Agent logs
            if (sources.agent && sources.agent.length > 0) {
                html += '<div class="log-section">';
                html += '<h4>Agent Service Logs (journalctl -u ai-agent):</h4>';
                html += '<pre>' + sources.agent.join('\n') + '</pre>';
                html += '</div>';
                totalLogLines += sources.agent.length;
            }
            
            // Systemd/service logs
            if (sources.systemd && sources.systemd.length > 0) {
                html += '<div class="log-section">';
                html += '<h4>Service Manager Logs (systemd/rc.d):</h4>';
                html += '<pre>' + sources.systemd.join('\n') + '</pre>';
                html += '</div>';
                totalLogLines += sources.systemd.length;
            }
            
            // Hub logs (if available)
            if (sources.hub && sources.hub.length > 0) {
                html += '<div class="log-section">';
                html += '<h4>Hub Logs:</h4>';
                html += '<pre>' + sources.hub.join('\n') + '</pre>';
                html += '</div>';
                totalLogLines += sources.hub.length;
            }
            
            if (totalLogLines === 0) {
                html = '<p style="text-align: center; margin: 20px;">No logs found for correlationId: <code>' + sources.correlationId + '</code></p>';
                html += '<p style="text-align: center; color: var(--text-muted);">This could mean the command hasn\'t been executed yet or logs haven\'t been written.</p>';
            } else {
                html = '<p style="margin-bottom: 10px;">Found ' + totalLogLines + ' log entries for correlationId: <code>' + sources.correlationId + '</code></p>' + html;
            }
            
            return html;
        }
        
        // Listen for execution updates via EventSource
        let executionEventSource = null;
        const executionListeners = new Map();
        let reconnectAttempts = 0;
        let reconnectTimeout = null;
        
        // Wait for multiple operations to complete via correlation tracking
        async function waitForOperationsToComplete(correlationIds, timeout = 60000) {
            console.log(`Waiting for ${correlationIds.length} operations to complete:`, correlationIds);
            
            return new Promise((resolve) => {
                const startTime = Date.now();
                const checkInterval = 500; // Check every 500ms
                
                const checkCompletion = () => {
                    const commands = getStoredCommands();
                    const statuses = correlationIds.map(id => {
                        const cmd = commands.find(c => c.correlationId === id);
                        return { id, status: cmd?.status || 'not found' };
                    });
                    
                    const allCompleted = statuses.every(s => 
                        s.status === 'completed' || s.status === 'failed'
                    );
                    
                    if (allCompleted) {
                        console.log('All operations completed:', statuses);
                        resolve(true);
                    } else if (Date.now() - startTime > timeout) {
                        console.log('Timeout waiting for operations to complete. Current statuses:', statuses);
                        resolve(false);
                    } else {
                        // Log pending operations periodically
                        const pending = statuses.filter(s => s.status === 'pending');
                        if (pending.length > 0 && (Date.now() - startTime) % 2000 < checkInterval) {
                            console.log(`Still waiting for ${pending.length} operations:`, pending);
                        }
                        setTimeout(checkCompletion, checkInterval);
                    }
                };
                
                checkCompletion();
            });
        }
        
        function listenForExecutionUpdates(correlationId) {
            // Add to listeners first
            executionListeners.set(correlationId, true);
            console.log(`[EventSource] Added listener for ${correlationId}, total listeners: ${executionListeners.size}`);
            
            // If EventSource already exists and is open, we're done
            if (executionEventSource && executionEventSource.readyState !== EventSource.CLOSED) {
                console.log(`[EventSource] Using existing connection (state: ${executionEventSource.readyState})`);
                return;
            }
            
            // Create new EventSource if needed
            if (!executionEventSource || executionEventSource.readyState === EventSource.CLOSED) {
                console.log('Creating new EventSource connection for executions');
                executionEventSource = new EventSource(`${API_BASE}/executions/stream`);
                
                executionEventSource.onopen = () => {
                    console.log('EventSource connected');
                    reconnectAttempts = 0; // Reset on successful connection
                };
                
                executionEventSource.onmessage = (event) => {
                    try {
                        const execution = JSON.parse(event.data);
                        
                        // Only process if this correlationId is from our current session
                        if (!activeCorrelationIds.has(execution.correlationId)) {
                            return; // Ignore executions from other sessions
                        }
                        
                        console.log('[EventSource] Received execution update:', execution);
                        
                        // Log the EventSource update
                        if (execution.correlationId && execution.agent) {
                            hubGuiLog.log(execution.agent, execution.correlationId, 'callback-received', 
                                `EventSource received ${execution.status} callback for ${execution.command}`);
                        }
                        
                        // Update command with matching correlationId
                        const commands = getStoredCommands();
                        const command = commands.find(c => c.correlationId === execution.correlationId);
                        if (command) {
                            console.log(`[EventSource] Updating command ${execution.correlationId} with timing info`);
                            
                            // Store previous status for logging
                            const previousStatus = command.status;
                            
                            // Handle late callbacks for start operations that previously timed out
                            if (command.status === 'timeout' && execution.status === 'success' && command.command.includes('start')) {
                                console.log(`[EventSource] Late callback received for ${execution.correlationId} - updating to timeoutSuccess`);
                                command.status = 'timeoutSuccess';
                                execution.status = 'timeoutSuccess'; // Update execution status too
                            } else {
                                command.status = execution.status || 'pending';
                            }
                            
                            // Log UI event for status change
                            if (previousStatus !== command.status) {
                                hubGuiLog.log(execution.agent || command.agent, execution.correlationId, 'console-status-changed', 
                                    `Console entry status changed from ${previousStatus} to ${command.status}`);
                            }
                            
                            command.timingInfo = formatTimingInfo(execution);
                            
                            // Update the specific time fields
                            if (execution.callbackTime) {
                                command.callbackTime = execution.callbackTime;
                            }
                            if (execution.pollingDetectedTime) {
                                command.pollingDetectedTime = execution.pollingDetectedTime;
                            }
                            
                            if (execution.endTime) {
                                command.duration = execution.endTime - execution.startTime;
                            }
                            if (execution.error) {
                                command.error = execution.error;
                            }
                            // Already updating in-memory executionHistory
                            renderConsoleTable();
                            
                            // Clear timeout if command is complete
                            if (execution.status !== 'pending' && commandTimeouts.has(execution.correlationId)) {
                                clearTimeout(commandTimeouts.get(execution.correlationId));
                                commandTimeouts.delete(execution.correlationId);
                            }
                        }
                        
                        // Also call updateCommandStatus if we're actively listening
                        if (execution.correlationId && executionListeners.has(execution.correlationId)) {
                            updateCommandStatus(execution.correlationId, execution);
                        }
                    } catch (error) {
                        console.error('[EventSource] Error processing message:', error, event.data);
                    }
                };
                
                executionEventSource.onerror = (error) => {
                    console.warn('EventSource error:', error);
                    
                    // Clear any existing reconnect timeout
                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }
                    
                    // If the connection is closed, try to reconnect
                    if (executionEventSource.readyState === EventSource.CLOSED) {
                        reconnectAttempts++;
                        
                        if (reconnectAttempts > 3) {
                            console.warn('EventSource: Max reconnection attempts reached, stopping');
                            cleanupEventSource();
                            return;
                        }
                        
                        console.warn(`EventSource: Connection closed (attempt ${reconnectAttempts}/3), retrying in 5s...`);
                        
                        // Close and cleanup
                        cleanupEventSource();
                        
                        // Reconnect after 5 seconds if we have pending commands
                        reconnectTimeout = setTimeout(() => {
                            const commands = getStoredCommands();
                            const hasPendingCommands = commands.some(cmd => cmd.correlationId && cmd.status === 'pending');
                            
                            if (hasPendingCommands) {
                                console.log('Reconnecting EventSource for pending commands');
                                // Just need to call once, it will create the connection
                                listenForExecutionUpdates(commands.find(cmd => cmd.correlationId && cmd.status === 'pending').correlationId);
                            }
                        }, 5000);
                    }
                };
            }
        }
        
        function cleanupEventSource() {
            if (executionEventSource) {
                executionEventSource.close();
                executionEventSource = null;
            }
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }
        }
        
        function updateCommandStatus(correlationId, execution) {
            // Check if this is a parent command (client-side only)
            const isParentCommand = correlationId && (
                correlationId.startsWith('start-all_') || 
                correlationId.startsWith('stop-all_') ||
                correlationId.startsWith('parent_')
            );
            
            // For parent commands, we don't need the listener check
            if (!isParentCommand && !executionListeners.has(correlationId)) return;
            
            const commands = getStoredCommands();
            const command = commands.find(c => c.correlationId === correlationId);
            
            if (command) {
                command.status = execution.status;
                
                // Log callback receipt if this is a completion status
                if (execution.status !== 'pending' && command.startTime) {
                    const callbackDuration = (Date.now() - command.startTime) / 1000;
                    console.log(`[${new Date().toISOString()}] Callback received for ${command.agent} (${callbackDuration.toFixed(2)}s)`);
                }
                
                // Update the specific time fields
                if (execution.callbackTime) {
                    command.callbackTime = execution.callbackTime;
                }
                if (execution.pollingDetectedTime) {
                    command.pollingDetectedTime = execution.pollingDetectedTime;
                }
                
                if (execution.endTime || execution.status === 'completed' || execution.status === 'failed') {
                    command.duration = (execution.endTime || Date.now()) - command.startTime;
                }
                if (execution.error) {
                    command.error = execution.error;
                }
                
                // Update timing information with our three timestamps
                command.timingInfo = formatTimingInfo(execution);
                
                // Instant status update: Update A/M icons when callback is received
                if (execution.status === 'success' || execution.status === 'failed' || 
                    execution.status === 'timeout' || execution.status === 'manualTermination') {
                    // Get the command string from the stored command object
                    const commandString = command.command || execution.command || '';
                    updateAgentStatusInstantly(command.agent, commandString, execution.status);
                }
                
                // Already updating in-memory executionHistory
                renderConsoleTable();
                
                // Stop listening if command is complete
                if (execution.status !== 'pending') {
                    executionListeners.delete(correlationId);
                    
                    // Clear client-side timeout if it exists
                    if (commandTimeouts.has(correlationId)) {
                        clearTimeout(commandTimeouts.get(correlationId));
                        commandTimeouts.delete(correlationId);
                    }
                    
                    // Check if parent command should be updated
                    if (command.parentId) {
                        checkParentCompletion(command.parentId);
                    }
                }
            }
        }
        
        // Version check is now handled in loadHubStatus() using the actual hub version
    </script>
</body>
</html>